/*!
 * Kevlar JS Library
 * Copyright(c) 2011 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 */
(function(){tests.unit=new Ext.test.TestSuite("unit");tests.unit.attribute=new Ext.test.TestSuite("attribute").addTo(tests.unit);tests.unit.data=new Ext.test.TestSuite("data").addTo(tests.unit);tests.unit.persistence=new Ext.test.TestSuite("persistence").addTo(tests.unit);tests.unit.util=new Ext.test.TestSuite("util").addTo(tests.unit);Ext.test.Session.addSuite(tests.unit)})();tests.unit.add(new Ext.test.TestSuite({name:"Kevlar.Model",items:[{name:"Test the onClassExtended static method","After extending model, the subclass should have a unique __Kevlar_modelTypeId property":function(){var a=Kevlar.Model.extend({});Y.Assert.isNumber(a.__Kevlar_modelTypeId,"The Model should now have a static __Kevlar_modelTypeId property that is a number")},"Attributes should inherit from a Model subclass's superclass when the subclass defines no attributes of its own":function(){var c=Kevlar.Model.extend({attributes:["field1"]});var b=c.extend({});var a=(new b()).attributes;Y.Assert.areSame(1,Kevlar.util.Object.length(a),"There should be exactly 1 attribute");Y.ObjectAssert.hasKey("field1",a,"field1 should exist as the attribute")},"Attributes should inherit from a Model subclass's superclass when the subclass does define attributes of its own":function(){var c=Kevlar.Model.extend({});var b=c.extend({addAttributes:["a","b"]});var a=(new b()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and its superclass as well (i.e. more than one level up)":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{addAttributes:["a","b"]});var c=Kevlar.extend(b,{addAttributes:["c","d","e"]});var a=(new c()).attributes;Y.Assert.areSame(5,Kevlar.util.Object.length(a),"There should be exactly 5 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and all of its superclasses (i.e. more than two levels up)":function(){var e=Kevlar.Model.extend({});var c=Kevlar.extend(e,{addAttributes:["a","b"]});var d=Kevlar.extend(c,{addAttributes:["c","d","e"]});var b=Kevlar.extend(d,{addAttributes:["f"]});var a=(new b()).attributes;Y.Assert.areSame(6,Kevlar.util.Object.length(a),"There should be exactly 6 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("f",a,"SubSubSubClassModel should have the 'f' attribute defined in its final 'attributes' hash.")},"Attribute definitions defined in a subclass should take precedence over attribute definitions in a superclass":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{addAttributes:[{name:"a",defaultValue:1}]});var c=Kevlar.extend(b,{addAttributes:[{name:"a",defaultValue:2},"b"]});var a=(new c()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.Assert.areSame(2,a.a.defaultValue,"The attribute in the subclass should have overridden its superclass")},"A subclass that doesn't define any attributes should inherit all of them from its superclass(es)":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{addAttributes:["a","b"]});var c=Kevlar.extend(b,{});var a=(new c()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"A superclass that doesn't define any attributes should be skipped for attributes, but the subclass should still inherit from superclasses above it":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{});var c=Kevlar.extend(b,{addAttributes:["a","b"]});var a=(new c()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"One should be able to use `attributes` in place of `addAttributes` on the prototype, if they wish":function(){var c=Kevlar.Model.extend({attributes:["a","b"]});var b=c.extend({attributes:["c"]});var a=(new b()).attributes;Y.Assert.areSame(3,Kevlar.util.Object.length(a),"There should be exactly 3 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.")}},{name:"Test the getAttributes() static method","The getAttributes() static method should retrieve a hashmap of the attributes for the model":function(){var a=Kevlar.Model.extend({attributes:[{name:"id",type:"number"},{name:"superclassAttr",type:"string"}]});var c=a.extend({attributes:[{name:"subclassAttr",type:"boolean"}]});var f=a.getAttributes();var e=Kevlar.util.Object.keysToArray(f);Y.Assert.areSame(2,e.length,"There should have been 2 keys in the array for the superclassModelAttrKeys");Y.Assert.areSame("id",e[0],"The first attribute in the superclass should be 'id'");Y.Assert.areSame("superclassAttr",e[1],"The second attribute in the superclass should be 'superclassAttr'");Y.Assert.isInstanceOf(Kevlar.attribute.NumberAttribute,f.id,"The `id` Attribute should have been an instance of NumberAttribute");Y.Assert.isInstanceOf(Kevlar.attribute.StringAttribute,f.superclassAttr,"The `superclassAttr` Attribute should have been an instance of StringAttribute");var b=c.getAttributes();var d=Kevlar.util.Object.keysToArray(b);Y.Assert.areSame(3,d.length,"There should have been 3 keys in the array for the subclassModelAttrKeys");Y.Assert.areSame("id",d[0],"The first attribute in the sublass should be 'id'");Y.Assert.areSame("superclassAttr",d[1],"The second attribute in the subclass should be 'superclassAttr'");Y.Assert.areSame("subclassAttr",d[2],"The third attribute in the subclass should be 'subclassAttr'");Y.Assert.isInstanceOf(Kevlar.attribute.NumberAttribute,b.id,"The `id` Attribute should have been an instance of NumberAttribute");Y.Assert.isInstanceOf(Kevlar.attribute.StringAttribute,b.superclassAttr,"The `superclassAttr` Attribute should have been an instance of StringAttribute");Y.Assert.isInstanceOf(Kevlar.attribute.BooleanAttribute,b.subclassAttr,"The `subclassAttr` Attribute should have been an instance of BooleanAttribute")}},{name:"Test Initialization (constructor)",ttype:"testsuite",items:[{name:"Test lazy instantiating a persistenceProxy",_should:{error:{"Attempting to instantiate a persistenceProxy with no 'type' attribute should throw an error":"Kevlar.persistence.Proxy.create(): No `type` property provided on persistenceProxy config object","Attempting to instantiate a persistenceProxy with an invalid 'type' attribute should throw an error":"Kevlar.persistence.Proxy.create(): Unknown Proxy type: 'nonexistentproxy'"}},"Attempting to instantiate a persistenceProxy with no 'type' attribute should throw an error":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{}});var a=new b()},"Attempting to instantiate a persistenceProxy with an invalid 'type' attribute should throw an error":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"nonExistentProxy"}});var a=new b()},"Providing a valid config object should instantiate the Proxy *on class's the prototype*":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"rest"}});var a=new b();Y.Assert.isInstanceOf(Kevlar.persistence.RestProxy,b.prototype.persistenceProxy)},"Providing a valid config object should instantiate the Proxy *on the correct subclass's prototype*, shadowing superclasses":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"nonExistentProxy"}});var c=Kevlar.extend(b,{addAttributes:["attribute1"],persistenceProxy:{type:"rest"}});var a=new c();Y.Assert.isInstanceOf(Kevlar.persistence.RestProxy,c.prototype.persistenceProxy)}},{name:"Test change event upon initialization",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+a.get("attribute2")}}]})},"The Model should fire its 'change' event when an attribute's data is set externally":function(){var b=false;var a=new this.TestModel();a.addListener("change",function(){b=true});a.set("attribute1","value1");Y.Assert.isTrue(b,"The change event should have been fired during the set of the new data")}},{name:"Test that the initial default values are applied",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"A attribute with a defaultValue but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"A attribute with a defaultValue that is a function, but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"A attribute with a defaultValue and also provided data should have its provided data when retrieved":function(){var a=new this.TestModel({attribute2:"attribute2's data"});Y.Assert.areSame("attribute2's data",a.get("attribute2"),"The 'default' specified on the Attribute should *not* have been applied, since it has a value.")}},{name:"Test initial data","Providing initial data to the constructor should not leave the model set as 'dirty' (i.e. it should have no 'changes')":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new b({attribute1:"value1",attribute2:"value2"});Y.Assert.isFalse(a.isDirty(),"The model should not be dirty upon initialization");Y.Assert.isTrue(Kevlar.util.Object.isEmpty(a.getChanges()),"There should not be any 'changes' upon initialization")}},{name:"Test that initialize() is called","The initialize() method should be called with the constructor function, for subclass initialization":function(){var b=false;var c=Kevlar.Model.extend({addAttributes:["test",{name:"test2",defaultValue:"defaultForTest2"}],initialize:function(){b=true}});var a=new c();Y.Assert.isTrue(b,"The initialize() method should have been called")}}]},{name:"Test getId()",_should:{error:{"getId() should throw an error if the default idAttribute 'id' does not exist on the model":"Error: The `idAttribute` (currently set to an attribute named 'id') was not found on the Model. Set the `idAttribute` config to the name of the id attribute in the Model. The model can't be saved or destroyed without it.","getId() should throw an error with a custom idAttribute that does not relate to an attribute on the model":"Error: The `idAttribute` (currently set to an attribute named 'myIdAttribute') was not found on the Model. Set the `idAttribute` config to the name of the id attribute in the Model. The model can't be saved or destroyed without it."}},"getId() should throw an error if the default idAttribute 'id' does not exist on the model":function(){var b=Kevlar.Model.extend({attributes:["field1","field2"]});var a=new b();a.getId();Y.Assert.fail("The test should have errored")},"getId() should throw an error with a custom idAttribute that does not relate to an attribute on the model":function(){var b=Kevlar.Model.extend({attributes:["field1","field2"],idAttribute:"myIdAttribute"});var a=new b();a.getId();Y.Assert.fail("The test should have errored")},"getId() should return the value of the idAttribute":function(){var b=Kevlar.Model.extend({attributes:["myIdAttribute"],idAttribute:"myIdAttribute"});var a=new b({myIdAttribute:1});Y.Assert.areSame(1,a.getId())}},{name:"Test getIdAttribute()","getIdAttribute() should return the Kevlar.attribute.Attribute referenced by the 'idAttribute' config":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var a=new b();Y.Assert.isInstanceOf(Kevlar.attribute.Attribute,a.getIdAttribute())},"getIdAttribute() should return null if there is no attribute referenced by the 'idAttribute' config":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"ooglyBoogly"});var a=new b();Y.Assert.isNull(a.getIdAttribute())}},{name:"Test getIdAttributeName()","getIdAttributeName() should return the value of the 'idAttribute' config":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"myBrandyNewIdAttribute"});var a=new b();Y.Assert.areSame("myBrandyNewIdAttribute",a.getIdAttributeName())}},{name:"Test hasIdAttribute()","hasIdAttribute should return false when the idAttribute config does not reference a valid Attribute":function(){var b=Kevlar.Model.extend({attributes:["attr"],idAttribute:"id"});var a=new b();Y.Assert.isFalse(a.hasIdAttribute())},"hasIdAttribute should return truue when the idAttribute config does reference a valid Attribute":function(){var b=Kevlar.Model.extend({attributes:["id","attr"],idAttribute:"id"});var a=new b();Y.Assert.isTrue(a.hasIdAttribute())}},{name:"Test set()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},_should:{error:{"set() should throw an error when trying to set an attribute that isn't defined (using the attr and value args)":"Kevlar.Model.set(): An attribute with the attributeName 'nonExistentAttr' was not found.","set() should throw an error when trying to set an attribute that isn't defined (using the attr as an object literal arg)":"Kevlar.Model.set(): An attribute with the attributeName 'nonExistentAttr' was not found."}},"set() should throw an error when trying to set an attribute that isn't defined (using the attr and value args)":function(){var a=new this.TestModel();a.set("nonExistentAttr",1);Y.Assert.fail("Test should have thrown an error")},"set() should throw an error when trying to set an attribute that isn't defined (using the attr as an object literal arg)":function(){var a=new this.TestModel();a.set({nonExistentAttr:1});Y.Assert.fail("Test should have thrown an error")},assertAttributeAcceptsAll:function(b,a){b.set(a,undefined);Y.Assert.isUndefined(b.get(a),a+"'s value should have the value set by set() (undefined).");b.set(a,null);Y.Assert.isNull(b.get(a),a+"'s value should have the value set by set() (null).");b.set(a,true);Y.Assert.isTrue(b.get(a),a+"'s value should have the value set by set() (true).");b.set(a,false);Y.Assert.isFalse(b.get(a),a+"'s value should have the value set by set() (false).");b.set(a,0);Y.Assert.areSame(0,b.get(a),a+"'s value should have the value set by set() (0).");b.set(a,1);Y.Assert.areSame(1,b.get(a),a+"'s value should have the value set by set() (1).");b.set(a,"");Y.Assert.areSame("",b.get(a),a+"'s value should have the value set by set() ('').");b.set(a,"Hello");Y.Assert.areSame("Hello",b.get(a),a+"'s value should have the value set by set() ('Hello').");b.set(a,{});Y.Assert.isObject(b.get(a),a+"'s value should have the value set by set() (object).");b.set(a,[]);Y.Assert.isArray(b.get(a),a+"'s value should have the value set by set() (array).")},"set() should accept all datatypes including falsy values":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute1")},"set() should accept all datatypes, and still work even with a default value":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute2")},"set() should accept all datatypes, and still work even with a given value":function(){var a=new this.TestModel({attribute2:"initial value"});this.assertAttributeAcceptsAll(a,"attribute2")},"After the successful set() of an attribute, the Model should be considered 'dirty'":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b();Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isTrue(a.isDirty(),"After a set, the model should now be considered 'dirty'")},"After a set() of an attribute to the same value from a clean state, the Model should NOT be considered 'dirty' (as the value didn't change)":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isFalse(a.isDirty(),"After a set to the *same value*, the model should not be considered 'dirty' (as the value didn't change)")},"set() should not re-set an attribute to the same value from the initial value provided to the constructor":function(){var c=0;var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(0,c,"The attribute should not have been registered as 'changed' when providing the same value")},"set() should not re-set an attribute to the same value":function(){var c=0;var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b();a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(1,c,"Initially, the attribute should have been changed exactly once.");a.set("attribute1","value1");Y.Assert.areSame(1,c,"The attribute should not have been registered as 'changed' the second time. Should still only have '1 change'.")},"set() should run the Attribute's set() method on an attribute that has initial data of its own":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(c){return c+" "+this.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute2val attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute1")},"set() should convert an attribute with a 'set' function when it is set() again":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(c){return c+" "+this.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});a.set("attribute2","newattribute2value");Y.Assert.areSame("newattribute2value attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute2")},"When set() is provided an Object (hashmap) of data to set, the attributes with user-provided 'set' methods should be run after ones with out any (in case they rely on the ones without setters)":function(){var b=Kevlar.Model.extend({attributes:[{name:"attr_with_setter1",set:function(c){return this.get("attr_without_setter")+c}},{name:"attr_without_setter"},{name:"attr_with_setter2",set:function(c){return this.get("attr_without_setter")+c}}]});var a=new b();a.set({attr_with_setter1:1,attr_without_setter:2,attr_with_setter2:3});Y.Assert.areSame(3,a.get("attr_with_setter1"),"The value should have been added from the attr_without_setter");Y.Assert.areSame(2,a.get("attr_without_setter"),"The value should have been simply provided to attr_without_setter");Y.Assert.areSame(5,a.get("attr_with_setter2"),"The value should have been added from the attr_without_setter")},"set() should delegate to the Attribute's beforeSet() and afterSet() methods to do any pre and post processing needed for the value":function(){var e,b;var a=Kevlar.attribute.Attribute.extend({beforeSet:function(g,h,f){return(e=h+1)},afterSet:function(f,g){return(b=g+20)}});var d=Kevlar.Model.extend({attributes:[new a({name:"attr1",set:function(f){return f+5}})]});var c=new d({attr1:0});Y.Assert.areSame(1,e);Y.Assert.areSame(26,b)},"When an attribute is set, a generalized 'change' event should be fired":function(){var c=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1","attribute2"]});var b=new c(),d=false,e,f,a;b.addListener("change",function(h,g,j,i){d=true;e=g;f=j;a=i});b.set("attribute2","brandNewValue");Y.Assert.isTrue(d,"The 'change' event was not fired");Y.Assert.areSame("attribute2",e,"The attributeName that was changed was not provided to the event correctly.");Y.Assert.areSame("brandNewValue",f,"The value for attribute2 that was changed was not provided to the event correctly.");Y.Assert.isUndefined(a,"The oldValue for attribute2 that was changed was not provided to the event correctly. Should have been undefined, from having no original value")},"When an attribute is set, a 'change:xxx' event should be fired for the changed attribute":function(){var c=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1","attribute2"]});var b=new c(),d=false,e,a;b.addListener("change:attribute2",function(f,h,g){d=true;e=h;a=g});b.set("attribute2","brandNewValue");Y.Assert.isTrue(d,"The 'change:attribute2' event was not fired");Y.Assert.areSame("brandNewValue",e,"The value for attribute2 that was changed was not provided to the event correctly.");Y.Assert.isUndefined(a,"The oldValue for attribute2 that was changed was not provided to the event correctly. Should have been undefined, from having no original value")},"When an attribute with a `set()` function of its own is set, the 'change' events should be fired":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1",set:function(g){return g}},{name:"attribute2",set:function(g){}}]});var a=new b(),e=0,f,c=0,d;a.addListener("change:attribute1",function(g,h){e++;f=h});a.addListener("change:attribute2",function(g,h){c++;d=h});a.set("attribute1","attribute1value1");Y.Assert.areSame(1,e,"The attribute1 change event count should now be 1, with the initial value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value1",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should now be 2, with a new value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value2",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, being set to the same value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");a.set("attribute2","attribute2value1");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it");Y.Assert.areSame(1,c,"The attribute2 change event count should now be 1, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should have been undefined, as its set() function does not return anything");a.set("attribute2","attribute2value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it (2nd time)");Y.Assert.areSame(2,c,"The attribute2 change event count should now be 2, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should still be undefined, as its set() function does not return anything")},"When an attribute with only a `get()` function is set, the 'change' events should be fired with the value from the get function, not the raw value (for both the newValue, and oldValue)":function(){var d=Kevlar.extend(Kevlar.Model,{attributes:[{name:"myAttribute",get:function(g){return g+10}}]});var c=new d({myAttribute:10}),e,a,f,b;c.on({change:function(i,h,j,g){e=j;a=g},"change:myAttribute":function(h,i,g){f=i;b=g}});c.set("myAttribute",42);Y.Assert.areSame(52,e,"The newValue provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(20,a,"The oldValue provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(52,f,"The newValue provided with the attribute-specific change event should have come from myAttribute's `get()` function");Y.Assert.areSame(20,b,"The oldValue provided with the attribute-specific change event should have come from myAttribute's `get()` function")},"When an attribute with both a `set()` function, and `get()` function of its own is set, the 'change' events should be fired with the value from the `get()` function, not the raw value":function(){var d=Kevlar.extend(Kevlar.Model,{addAttributes:["baseAttribute",{name:"computedAttribute",set:function(g){this.set("baseAttribute",g)},get:function(g){return this.get("baseAttribute")+10}}]});var c=new d({baseAttribute:10}),e,a,f,b;c.on({change:function(i,h,j,g){e=j;a=g},"change:computedAttribute":function(h,i,g){f=i;b=g}});c.set("computedAttribute",42);Y.Assert.areSame(52,e,"The newValue provided with the change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(20,a,"The oldValue provided with the change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(52,f,"The newValue provided with the attribute-specific change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(20,b,"The oldValue provided with the attribute-specific change event should have come from computedAttribute's `get()` function")},"When multiple attributes are set, a generalized 'changeset' event should be fired exactly once":function(){var e=Kevlar.extend(Kevlar.Model,{addAttributes:["a","b","c","unModifiedAttr"]});var d=new e({a:1,b:2,c:3}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b");Y.Assert.areSame(3,d.get("c"),"initial value for c");d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set({a:11,b:22,c:33});Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(3,Kevlar.util.Object.length(c),"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,Kevlar.util.Object.length(a),"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(22,c.b,"newValue for 'b'");Y.Assert.areSame(33,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'")},"When a computed attribute changes other attributes, the generalized 'changeset' event should still be only fired exactly once":function(){var e=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"a",set:function(f){this.set("b",f+1);this.set("c",f+2);return f}},{name:"b"},{name:"c"},{name:"unModifiedAttr"}]});var d=new e({a:1}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b. Should be set by the 'a' attribute's setter");Y.Assert.areSame(3,d.get("c"),"initial value for c. Should be set by the 'a' attribute's setter");d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set("a",11);Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(12,d.get("b"));Y.Assert.areSame(13,d.get("c"));Y.Assert.areSame(3,Kevlar.util.Object.length(c),"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,Kevlar.util.Object.length(a),"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(12,c.b,"newValue for 'b'");Y.Assert.areSame(13,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'")},"When an attribute changes, and a handler of the change ends up setting other attributes, the generalized 'changeset' event should still be only fired exactly once":function(){var e=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"a"},{name:"b"},{name:"c"},{name:"unModifiedAttr"}]});var d=new e({a:1,b:2,c:3}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b");Y.Assert.areSame(3,d.get("c"),"initial value for c");d.addListener("change:a",function(g,h,f){g.set("b",22);g.set("c",33)});d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set("a",11);Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(22,d.get("b"));Y.Assert.areSame(33,d.get("c"));Y.Assert.areSame(3,Kevlar.util.Object.length(c),"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,Kevlar.util.Object.length(a),"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(22,c.b,"newValue for 'b'");Y.Assert.areSame(33,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'")},"When an attribute is changed multiple times within a single 'changeset', its oldValue value should have its *original* value (not any intermediate values)":function(){var e=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"a"}]});var d=new e({a:1}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");d.addListener("change:a",function(g,h,f){g.set("a",3);g.set("a",4)},this,{single:true});d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set("a",2);Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(4,d.get("a"));Y.Assert.areSame(1,Kevlar.util.Object.length(c),"The changeset's newValues should have exactly 1 property");Y.Assert.areSame(1,Kevlar.util.Object.length(a),"The changeset's oldValues should have exactly 1 property");Y.Assert.areSame(4,c.a,"newValue for 'a'");Y.Assert.areSame(1,a.a,"oldValue for 'a'")},"multiple 'changeset' events should work correctly, providing the correct newValues and oldValues each time":function(){var e=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"a"},{name:"b"},{name:"c"},{name:"unModifiedAttr"}]});var d=new e({a:1,b:2,c:3}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b");Y.Assert.areSame(3,d.get("c"),"initial value for c");d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set({a:11,b:22,c:33});Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(22,d.get("b"));Y.Assert.areSame(33,d.get("c"));Y.Assert.areSame(3,Kevlar.util.Object.length(c),"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,Kevlar.util.Object.length(a),"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(22,c.b,"newValue for 'b'");Y.Assert.areSame(33,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'");d.set({b:222,c:333});Y.Assert.areSame(2,b,"The 'changeset' event should have been fired exactly twice at this point (one more than the last test)");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(222,d.get("b"));Y.Assert.areSame(333,d.get("c"));Y.Assert.areSame(2,Kevlar.util.Object.length(c),"The changeset's newValues should have exactly 2 properties");Y.Assert.areSame(2,Kevlar.util.Object.length(a),"The changeset's oldValues should have exactly 2 properties");Y.Assert.areSame(222,c.b,"newValue for 'b'");Y.Assert.areSame(333,c.c,"newValue for 'c'");Y.Assert.areSame(22,a.b,"oldValue for 'b'");Y.Assert.areSame(33,a.c,"oldValue for 'c'")},"for compatibility with Backbone's Collection, set() should set the id property to the Model object itself with the idAttribute is changed":function(){var b=Kevlar.Model.extend({addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(c){return c+" "+this.get("attribute1")}}],idAttribute:"attribute1"});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute1val",a.id,"The model's `id` property should have been set to attribute1's value, as that is the idAttribute.");a.set("attribute1","newValue");Y.Assert.areSame("newValue",a.id,"The model's `id` property should have been set to attribute1's value after another set(), as that is the idAttribute.")}},{name:"Test get()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",get:function(a){return this.get("attribute1")+" "+this.get("attribute2")}}]})},"running get() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.get("attribute1"))},"running get() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.get("attribute1"))},"running get() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"running get() on an attribute with an initial value and a default value should return the initial value":function(){var a=new this.TestModel({attribute2:"initial value"});Y.Assert.areSame("initial value",a.get("attribute2"))},"running get() on an attribute with no initial value but does have a default value which is a function should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"running get() on an attribute with a `get` function defined should return the value that the `get` function returns":function(){var a=new this.TestModel({attribute1:"value1"});Y.Assert.areSame("value1 attribute2's default",a.get("attribute5"))}},{name:"Test raw()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",get:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute4",raw:function(a){return a+" "+this.get("attribute1")}}]})},"running raw() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.raw("attribute1"))},"running raw() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.raw("attribute1"))},"running raw() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.raw("attribute2"))},"running raw() on an attribute with a `get` function defined should return the *underlying* value, not the value that the `get` function returns":function(){var a=new this.TestModel({attribute3:"value1"});Y.Assert.areSame("value1",a.raw("attribute3"))},"running raw() on an attribute with a `raw` function defined should return the value that the `raw` function returns":function(){var a=new this.TestModel({attribute1:"value1",attribute4:"value4"});Y.Assert.areSame("value4 value1",a.raw("attribute4"))}},{name:"Test getDefault()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"A attribute with no defaultValue should return undefined when trying to retrieve its default value":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.getDefault("attribute1"))},"A defaultValue should be able to be retrieved directly when the attribute has one":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.getDefault("attribute2"))},"A defaultValue should be able to be retrieved directly when the defaultValue is a function that returns its default":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.getDefault("attribute3"))}},{name:"Test onEmbeddedDataComponentChange()","onEmbeddedDataComponentChange() should ":function(){}},{name:"Test isDirty()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"isDirty() should return false after instantiating a Model with no data":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after instantiating a Model with initial data":function(){var a=new this.TestModel({attribute1:1,attribute2:2});Y.Assert.isFalse(a.isDirty())},"isDirty() should return true after setting an attribute's data":function(){var a=new this.TestModel();a.set("attribute1",1);Y.Assert.isTrue(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then rolling back the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.rollback();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then committing the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.commit();Y.Assert.isFalse(a.isDirty())}},{name:"Test isModified()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]});this.ConcreteDataComponentAttribute=Kevlar.attribute.DataComponentAttribute.extend({});this.ConcreteDataComponent=Kevlar.DataComponent.extend({getData:Kevlar.emptyFn,isModified:Kevlar.emptyFn,commit:Kevlar.emptyFn,rollback:Kevlar.emptyFn})},"isModified should return false if there are no changes on the model":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isModified())},"isModified should return true if there is at least one change on the model":function(){var a=new this.TestModel();a.set("attribute1","newValue1");Y.Assert.isTrue(a.isModified())},"isModified should return true if there are multiple changes on the model":function(){var a=new this.TestModel();a.set("attribute1","newValue1");a.set("attribute2","newValue2");Y.Assert.isTrue(a.isModified())},"isModified() should return false for particular attributes that have not been changed, even if there are other changes":function(){var a=new this.TestModel();a.set("attribute3","testing123");Y.Assert.isFalse(a.isModified("attribute1"),"attribute1, with no defaultValue, should not be modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2, with a defaultValue, should not be modified")},"isModified() should return true for particular attributes that have been changed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified");Y.Assert.isTrue(a.isModified("attribute2"),"attribute2 should be marked as modified")},"isModified() should return false for particular attributes that have been changed, but then committed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been committed, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been committed, and therefore not marked as modified")},"isModified() should return false for particular attributes that have been changed, but then rolled back":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.rollback();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been rolled back, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been rolled back, and therefore not marked as modified")},"In the case of embedded DataComponents, the parent model should be considered 'modified' when a child embedded DataComponent has changes":function(){var b=Kevlar.Model.extend({attributes:[new this.ConcreteDataComponentAttribute({name:"child",embedded:true})]});var c=JsMockito.mock(this.ConcreteDataComponent);JsMockito.when(c).isModified().thenReturn(true);var a=new b({child:c});Y.Assert.isTrue(a.isModified(),"The parent model should be considered 'modified' while its child model is 'modified'");Y.Assert.isTrue(a.isModified("child"),"The 'child' attribute should be considered 'modified'")},"The parent model should *not* have changes when a child model has changes, but is not 'embedded'":function(){var b=Kevlar.Model.extend({attributes:[new this.ConcreteDataComponentAttribute({name:"child",embedded:false})]});var c=JsMockito.mock(this.ConcreteDataComponent);JsMockito.when(c).isModified().thenReturn(true);var a=new b({child:c});Y.Assert.isFalse(a.isModified(),"The parent model should not be considered 'modified' even though its child model is 'modified', because the child is not 'embedded'")},"If the persistedOnly option is provided as true, isModified() should return true only if a persisted attribute is modified":function(){var b=Kevlar.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]});var a=new b();Y.Assert.isFalse(a.isModified(),"Initial condition: the model should not be considered modified");a.set("unpersistedAttr","value1");Y.Assert.isTrue(a.isModified(),"The model should be considered 'modified' in general");Y.Assert.isFalse(a.isModified({persistedOnly:true}),"The model only has unpersisted attributes modified, so this call should return false");a.set("persistedAttr","value1");Y.Assert.isTrue(a.isModified(),"The model should still be considered 'modified' in general");Y.Assert.isTrue(a.isModified({persistedOnly:true}),"The model now has a persisted attribute that is modified. This should return true.")},"If the persistedOnly option is provided as true and a specific attribute name is given, isModified() should return true only if the attribute is both modified, and persisted":function(){var b=Kevlar.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]});var a=new b();Y.Assert.isFalse(a.isModified("persistedAttr"),"Initial condition: the 'persistedAttr' should not be considered modified");Y.Assert.isFalse(a.isModified("unpersistedAttr"),"Initial condition: the 'unpersistedAttr' should not be considered modified");a.set("unpersistedAttr","value1");Y.Assert.isTrue(a.isModified("unpersistedAttr"),"The 'unpersistedAttr' should be considered 'modified' in general");Y.Assert.isFalse(a.isModified("unpersistedAttr",{persistedOnly:true}),"The 'unpersistedAttr' is not persisted, so this call should return false, even though it has been changed");a.set("persistedAttr","value1");Y.Assert.isTrue(a.isModified("persistedAttr"),"The 'persistedAttr' should still be considered 'modified' in general");Y.Assert.isTrue(a.isModified("persistedAttr",{persistedOnly:true}),"The 'persistedAttr' is both modified, and persisted. This should return true.")}},{name:"Test getData()",setUp:function(){this.origNativeObjectConverter=Kevlar.data.NativeObjectConverter;var a=this.args={};Kevlar.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}}},tearDown:function(){Kevlar.data.NativeObjectConverter=this.origNativeObjectConverter},"getData() should delegate to the singleton NativeObjectConverter to create an Object representation of its data":function(){var d=Kevlar.Model.extend({attributes:["attr1","attr2"]});var b=new d({attr1:"value1",attr2:"value2"});var c={raw:true};var a=b.getData(c);Y.Assert.areSame(b,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the model.");Y.Assert.areSame(c,this.args[1],"The second arg provided to NativeObjectConverter::convert() should have been the options object")}},{name:"Test getChanges()",setUp:function(){this.origNativeObjectConverter=Kevlar.data.NativeObjectConverter;var a=this.args={};Kevlar.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}};this.ConcreteDataComponentAttribute=Kevlar.attribute.DataComponentAttribute.extend({});this.ConcreteDataComponent=Kevlar.DataComponent.extend({getData:Kevlar.emptyFn,isModified:Kevlar.emptyFn,commit:Kevlar.emptyFn,rollback:Kevlar.emptyFn})},tearDown:function(){Kevlar.data.NativeObjectConverter=this.origNativeObjectConverter},"getChanges() should delegate to the singleton NativeObjectConverter to create an Object representation of its data, but only provide changed attributes for the attributes that should be returned":function(){var e=Kevlar.Model.extend({attributes:["attr1","attr2","attr3",new this.ConcreteDataComponentAttribute({name:"nestedDataComponent",embedded:false}),new this.ConcreteDataComponentAttribute({name:"embeddedDataComponent",embedded:true})]});var c=JsMockito.mock(this.ConcreteDataComponent);JsMockito.when(c).isModified().thenReturn(true);var b=new e({attr1:"value1",attr2:"value2",attr3:"value3",nestedDataComponent:c,embeddedDataComponent:c});b.set("attr1","newValue1");b.set("attr2","newValue2");var a=b.getChanges({raw:true});var d=this.args[1];Y.Assert.areSame(b,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the model.");Y.Assert.areSame(true,d.raw,"The second arg provided to NativeObjectConverter::convert() should have receieved the 'raw:true' option");Y.ArrayAssert.itemsAreSame(["attr1","attr2","embeddedDataComponent"],d.attributeNames,"The second arg provided to NativeObjectConverter::convert() should have receieved the 'attributeNames' option, with the attributes that were changed")}},{name:"Test commit()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]});this.ConcreteDataComponent=Kevlar.DataComponent.extend({getData:Kevlar.emptyFn,isModified:Kevlar.emptyFn,commit:Kevlar.emptyFn,rollback:Kevlar.emptyFn})},"committing changed data should cause the 'dirty' flag to be reset to false, and getChanges() to return an empty object":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();var b=a.getChanges();Y.Assert.areSame(0,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 0 properties");Y.Assert.isFalse(a.isDirty(),"The model should no longer be marked as 'dirty'")},"committing changed data should cause rollback() to have no effect":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();a.rollback();Y.Assert.areSame("new value 1",a.get("attribute1"),"attribute1 should have been 'new value 1'. rollback() should not have had any effect.");Y.Assert.areSame("new value 2",a.get("attribute2"),"attribute2 should have been 'new value 2'. rollback() should not have had any effect.")},"committing changed data should fire the 'commit' event":function(){var a=0;var b=new this.TestModel();b.addListener("commit",function(){a++});b.set("attribute1","new value 1");b.set("attribute2","new value 2");b.commit();Y.Assert.areSame(1,a,"The 'commit' event should have been fired exactly once after committing.")},"committing a parent model should also commit any embedded child DataComponent that the model holds":function(){var e=Kevlar.attribute.DataComponentAttribute.extend({getData:Kevlar.emptyFn,isModified:Kevlar.emptyFn,commit:Kevlar.emptyFn,rollback:Kevlar.emptyFn});var d=Kevlar.Model.extend({attributes:[new e({name:"childDataComponent",embedded:true})]});var c=JsMockito.mock(this.ConcreteDataComponent);var a=new d();a.set("childDataComponent",c);a.commit();try{JsMockito.verify(c).commit()}catch(b){Y.Assert.fail(b)}}},{name:"Test rollback()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"rollback() should revert the model's values back to default values if before any committed set() calls":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.isUndefined(a.get("attribute1"));Y.Assert.areSame("attribute2's default",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values, when more than one set() call is made":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.set("attribute1","new value 1 - even newer");a.set("attribute2","new value 2 - even newer");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should fire the 'rollback' event":function(){var b=0;var a=new this.TestModel({attribute1:"orig1",attribute2:"orig2"});a.on("rollback",function(){b++});a.set("attribute1","new1");Y.Assert.areSame(0,b,"Initial condition: The rollback event should not have been fired yet");a.rollback();Y.Assert.areSame(1,b,"The rollback event should have been fired exactly once")}},{name:"Test reload()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},_should:{error:{"reload() should throw an error if there is no configured persistenceProxy":"Kevlar.Model::reload() error: Cannot load. No persistenceProxy."}},"reload() should throw an error if there is no configured persistenceProxy":function(){var a=new this.TestModel({});a.reload();Y.Assert.fail("reload() should have thrown an error with no configured persistenceProxy")},"reload() should delegate to its persistenceProxy's read() method to retrieve the data":function(){var b=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));var d=this.TestModel.extend({persistenceProxy:b});var a=new d();a.reload();try{JsMockito.verify(b).read()}catch(c){Y.Assert.fail(c)}}},{name:"Test save()",ttype:"testsuite",items:[{name:"General save() tests",setUp:function(){this.proxy=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}))},_should:{error:{"save() should throw an error if there is no configured persistenceProxy":"Kevlar.Model::save() error: Cannot save. No persistenceProxy."}},"save() should throw an error if there is no configured persistenceProxy":function(){var b=Kevlar.Model.extend({});var a=new b();a.save();Y.Assert.fail("save() should have thrown an error with no configured persistenceProxy")},"save() should delegate to its persistenceProxy's create() method to persist changes when the Model does not have an id set":function(){var c=Kevlar.Model.extend({addAttributes:["id"],idAttribute:"id",persistenceProxy:this.proxy});var a=new c();a.save();try{JsMockito.verify(this.proxy).create()}catch(b){Y.Assert.fail(b)}},"save() should delegate to its persistenceProxy's update() method to persist changes, when the Model has an id":function(){var c=Kevlar.Model.extend({addAttributes:["id"],idAttribute:"id",persistenceProxy:this.proxy});var a=new c({id:1});a.save();try{JsMockito.verify(this.proxy).update()}catch(b){Y.Assert.fail(b)}}},{name:"save() callbacks and promise tests",setUp:function(){this.proxy=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));this.Model=Kevlar.Model.extend({addAttributes:["id","attribute1"],persistenceProxy:this.proxy})},"save should call its 'success' and 'complete' callbacks if the persistenceProxy successfully creates":function(){this.proxy.create=function(e,d){if(d.success){d.success.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model();b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error while creating":function(){this.proxy.create=function(e,d){if(d.error){d.error.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model();b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'success' and 'complete' callbacks if the persistenceProxy successfully updates":function(){this.proxy.update=function(e,d){if(d.success){d.success.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model({id:1});b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error while updating":function(){this.proxy.update=function(e,d){if(d.error){d.error.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model({id:1});b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `done` and `always` callbacks executed when the persistenceProxy successfully creates":function(){this.proxy.create=function(g,f){if(f.success){f.success.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model();var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(1,c,"The 'done' function should have been called exactly once");Y.Assert.areSame(0,a,"The 'fail' function should not have been called");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `fail` and `always` callbacks executed when the persistenceProxy fails to create":function(){this.proxy.create=function(g,f){if(f.error){f.error.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model();var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(0,c,"The 'done' function should not have been called");Y.Assert.areSame(1,a,"The 'fail' function should have been called exactly once");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `done` and `always` callbacks executed when the persistenceProxy successfully updates":function(){this.proxy.update=function(g,f){if(f.success){f.success.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model({id:1});var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(1,c,"The 'done' function should have been called exactly once");Y.Assert.areSame(0,a,"The 'fail' function should not have been called");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `fail` and `always` callbacks executed when the persistenceProxy fails to update":function(){this.proxy.update=function(g,f){if(f.error){f.error.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model({id:1});var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(0,c,"The 'done' function should not have been called");Y.Assert.areSame(1,a,"The 'fail' function should have been called exactly once");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")}},{name:"Test basic persistence",setUp:function(){this.Model=Kevlar.Model.extend({addAttributes:["id","attribute1","attribute2"]})},"Model attributes that have been persisted should not be persisted again if they haven't changed since the last persist":function(){var b;var c=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));JsMockito.when(c).update().then(function(f,e){b=f.getChanges();e.success.call(e.scope)});var d=this.Model.extend({persistenceProxy:c});var a=new d({id:1});a.set("attribute1","newattribute1value");a.save();Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The dataToPersist should only have one key after attribute1 has been changed");Y.ObjectAssert.ownsKeys(["attribute1"],b,"The dataToPersist should have 'attribute1'");a.set("attribute2","newattribute2value");a.save();Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The dataToPersist should only have one key after attribute2 has been changed");Y.ObjectAssert.ownsKeys(["attribute2"],b,"The dataToPersist should have 'attribute2'")}},{name:"Test concurrent persistence and model updates",createModel:function(b){var a=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));JsMockito.when(a).update().then(function(d,c){window.setTimeout(function(){c.success.call(c.scope||window)},b)});return Kevlar.Model.extend({addAttributes:["id","attribute1","attribute2"],persistenceProxy:a})},"Model attributes that are updated (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var b=this.createModel(50),a=new b({id:1});a.set("attribute1","origValue1");a.set("attribute2","origValue2");a.save({success:function(){c.resume(function(){Y.Assert.isTrue(a.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue1",a.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",a.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.")})}});a.set("attribute1","newValue1");c.wait(100)},"Model attributes that are updated *more than once* (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var b=this.createModel(50),a=new b({id:1});a.set("attribute1","origValue1");a.set("attribute2","origValue2");a.save({success:function(){c.resume(function(){Y.Assert.isTrue(a.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue11",a.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",a.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.");a.rollback();Y.Assert.areSame("origValue1",a.get("attribute1"),"The value for attribute1 should have been rolled back to its original value")})}});a.set("attribute1","newValue1");a.set("attribute1","newValue11");c.wait(100)}},{name:"Test save() with related Collections",setUp:function(){this.proxy=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));this.Model=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"},{name:"c1",type:"collection"},{name:"c2",type:"collection"}],persistenceProxy:this.proxy});this.collection1=JsMockito.mock(Kevlar.Collection);JsMockito.when(this.collection1).getModels().thenReturn([]);this.collection2=JsMockito.mock(Kevlar.Collection);JsMockito.when(this.collection2).getModels().thenReturn([])},"save() should synchronize any nested 'related' (as opposed to 'embedded') collections before synchronizing itself":function(){var k=0,c=0,i=0,d=0;JsMockito.when(this.collection1).sync().then(function(){k++;var m=new jQuery.Deferred();m.done(function(){i++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.collection2).sync().then(function(){c++;var m=new jQuery.Deferred();m.done(function(){d++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.proxy).create().then(function(n,m){setTimeout(function(){m.success.call(m.scope)},25)});var g=new this.Model({attr:"attrValue",c1:this.collection1,c2:this.collection2});var h=0,l=0,j=0,b=0,a=0,e=0;var f=g.save({success:function(){h++},error:function(){l++},complete:function(){j++}});f.done(function(){b++}).fail(function(){a++}).always(function(){e++});Y.Assert.areSame(1,k,"sync() should have been called on collection1");Y.Assert.areSame(1,c,"sync() should have been called on collection2");Y.Assert.areSame(0,i,"collection1's sync should not yet be done");Y.Assert.areSame(0,d,"collection2's sync should not yet be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet");this.wait(function(){Y.Assert.areSame(1,i,"collection1's sync should now be done");Y.Assert.areSame(1,d,"collection2's sync should now be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet (2)");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet (2)");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet (2)");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet (2)");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet (2)");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet (2)");this.wait(function(){Y.Assert.areSame(1,h,"`complete` callback should have been called");Y.Assert.areSame(0,l,"`error` callback should NOT have been called");Y.Assert.areSame(1,j,"`complete` callback should have been called");Y.Assert.areSame(1,b,"`done` callback should have been called");Y.Assert.areSame(0,a,"`fail` callback should NOT have been called");Y.Assert.areSame(1,e,"`always` callback should have been called")},50)},75)},"save() should call the 'error' and 'fail' callbacks if a collection fails to synchronize":function(){var k=0,d=0,i=0,b=0;JsMockito.when(this.collection1).sync().then(function(){k++;var m=new jQuery.Deferred();m.done(function(){i++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.collection2).sync().then(function(){d++;var m=new jQuery.Deferred();m.fail(function(){b++});setTimeout(function(){m.reject()},50);return m});JsMockito.when(this.proxy).create().then(function(n,m){setTimeout(function(){m.success.call(m.scope)},25)});var g=new this.Model({attr:"attrValue",c1:this.collection1,c2:this.collection2});var h=0,l=0,j=0,c=0,a=0,e=0;var f=g.save({success:function(){h++},error:function(){l++},complete:function(){j++}});f.done(function(){c++}).fail(function(){a++}).always(function(){e++});Y.Assert.areSame(1,k,"sync() should have been called on collection1");Y.Assert.areSame(1,d,"sync() should have been called on collection2");Y.Assert.areSame(0,i,"collection1's sync should not yet be done");Y.Assert.areSame(0,b,"collection2's sync should not yet be failed");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet");Y.Assert.areSame(0,c,"Shouldn't have any done calls yet");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet");this.wait(function(){Y.Assert.areSame(1,i,"collection1's sync should now be done");Y.Assert.areSame(1,b,"collection2's sync should now be failed");Y.Assert.areSame(0,h,"`complete` callback NOT should have been called");Y.Assert.areSame(1,l,"`error` callback should have been called");Y.Assert.areSame(1,j,"`complete` callback should have been called");Y.Assert.areSame(0,c,"`done` callback should NOT have been called");Y.Assert.areSame(1,a,"`fail` callback should have been called");Y.Assert.areSame(1,e,"`always` callback should have been called")},75)},"save() should call the 'error' and 'fail' callbacks if collections synchronize, but the model itself fails to save":function(){var k=0,c=0,i=0,d=0;JsMockito.when(this.collection1).sync().then(function(){k++;var m=new jQuery.Deferred();m.done(function(){i++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.collection2).sync().then(function(){c++;var m=new jQuery.Deferred();m.done(function(){d++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.proxy).create().then(function(n,m){setTimeout(function(){m.error.call(m.scope)},25)});var g=new this.Model({attr:"attrValue",c1:this.collection1,c2:this.collection2});var h=0,l=0,j=0,b=0,a=0,e=0;var f=g.save({success:function(){h++},error:function(){l++},complete:function(){j++}});f.done(function(){b++}).fail(function(){a++}).always(function(){e++});Y.Assert.areSame(1,k,"sync() should have been called on collection1");Y.Assert.areSame(1,c,"sync() should have been called on collection2");Y.Assert.areSame(0,i,"collection1's sync should not yet be done");Y.Assert.areSame(0,d,"collection2's sync should not yet be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet");this.wait(function(){Y.Assert.areSame(1,i,"collection1's sync should now be done");Y.Assert.areSame(1,d,"collection2's sync should now be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet (2)");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet (2)");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet (2)");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet (2)");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet (2)");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet (2)");this.wait(function(){Y.Assert.areSame(0,h,"`complete` callback NOT should have been called");Y.Assert.areSame(1,l,"`error` callback should have been called");Y.Assert.areSame(1,j,"`complete` callback should have been called");Y.Assert.areSame(0,b,"`done` callback should NOT have been called");Y.Assert.areSame(1,a,"`fail` callback should have been called");Y.Assert.areSame(1,e,"`always` callback should have been called")},50)},75)}}]},{name:"Test destroy()",ttype:"testsuite",items:[{name:"General destroy() tests",_should:{error:{"destroy() should throw an error if there is no configured persistenceProxy when it tries to destroy a model that has been persisted (i.e. has an id)":"Kevlar.Model::destroy() error: Cannot destroy model on server. No persistenceProxy."}},"destroy() should throw an error if there is no configured persistenceProxy when it tries to destroy a model that has been persisted (i.e. has an id)":function(){var b=Kevlar.Model.extend({addAttributes:["id","attribute1","attribute2"]});var a=new b({id:1});a.destroy();Y.Assert.fail("destroy() should have thrown an error with no configured persistenceProxy")},"destroy() should delegate to its persistenceProxy's destroy() method to persist the destruction of the model":function(){var b=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));var d=Kevlar.Model.extend({attributes:["id"],persistenceProxy:b});var a=new d({id:1});a.destroy();try{JsMockito.verify(b).destroy()}catch(c){Y.Assert.fail("The model should have delegated to the destroy method exactly once.")}},"upon successful destruction of the Model, the Model should fire its 'destroy' event":function(){var b=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}));JsMockito.when(b).destroy().then(function(f,e){e.success.call(e.scope)});var d=Kevlar.Model.extend({attributes:["id"],persistenceProxy:b});var a=new d({id:1});var c=false;a.addListener("destroy",function(){c=true});a.destroy();Y.Assert.isTrue(c,"Should have fired its destroy event")}},{name:"destroy() callbacks and returned promise tests",setUp:function(){this.proxy=JsMockito.mock(Kevlar.persistence.Proxy.extend({create:Kevlar.emptyFn,read:Kevlar.emptyFn,update:Kevlar.emptyFn,destroy:Kevlar.emptyFn}))},"destroy() should call its 'success' and 'complete' callbacks if the persistenceProxy is successful":function(){var c=0,a=0;JsMockito.when(this.proxy).destroy().then(function(f,e){if(e.success){e.success.call(e.scope)}});var d=Kevlar.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new d({id:1});b.destroy({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"destroy() should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error":function(){var d=0,a=0;JsMockito.when(this.proxy).destroy().then(function(f,e){e.error.call(e.scope)});var c=Kevlar.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new c({id:1});b.destroy({error:function(){d++},complete:function(){a++},scope:this});Y.Assert.areSame(1,d,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"destroy() should return a jQuery.Promise object, which has its `done` and `always` callbacks executed upon successful completion":function(){var c=0,a=0,d=0;JsMockito.when(this.proxy).destroy().then(function(h,g){g.success.call(g.scope)});var f=Kevlar.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new f({id:1});var e=b.destroy().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(1,c,"The 'done' function should have been called exactly once");Y.Assert.areSame(0,a,"The 'fail' function should have not been called");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"destroy() should return a jQuery.Promise object, which has its `fail` and `always` callbacks executed upon an error while persisting":function(){var c=0,a=0,d=0;JsMockito.when(this.proxy).destroy().then(function(h,g){g.error.call(g.scope)});var f=Kevlar.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new f({id:1});var e=b.destroy().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(0,c,"The 'done' function should not have been called");Y.Assert.areSame(1,a,"The 'fail' function should have been called exactly once");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")}}]}]}));