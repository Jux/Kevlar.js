/*!
 * Kevlar JS Library
 * Copyright(c) 2011 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 */
(function(){tests.unit=new Ext.test.TestSuite("unit");tests.unit.attribute=new Ext.test.TestSuite("attribute").addTo(tests.unit);tests.unit.data=new Ext.test.TestSuite("data").addTo(tests.unit);tests.unit.persistence=new Ext.test.TestSuite("persistence").addTo(tests.unit);tests.unit.util=new Ext.test.TestSuite("util").addTo(tests.unit);Ext.test.Session.addSuite(tests.unit)})();tests.unit.add(new Ext.test.TestSuite({name:"Kevlar",items:[{name:"Test isArray()",test_isArray:function(){var a=Kevlar.extend(Object,{length:1});Y.Assert.isTrue(Kevlar.isArray([]),"Test with empty array");Y.Assert.isTrue(Kevlar.isArray([1,2,3,4]),"Test with filled array");Y.Assert.isFalse(Kevlar.isArray(false),"Test with boolean #1");Y.Assert.isFalse(Kevlar.isArray(true),"Test with boolean #2");Y.Assert.isFalse(Kevlar.isArray("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isArray(1),"Test with number");Y.Assert.isFalse(Kevlar.isArray(null),"Test with null");Y.Assert.isFalse(Kevlar.isArray(new Date()),"Test with a date");Y.Assert.isFalse(Kevlar.isArray({}),"Test with empty object");Y.Assert.isFalse(Kevlar.isArray(document.getElementsByTagName("body")),"Test with node list");Y.Assert.isFalse(Kevlar.isArray(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isArray(new a()),"Test with custom class that has a length property")}},{name:"Test isBoolean()",test_isBoolean:function(){Y.Assert.isTrue(Kevlar.isBoolean(true),"Test with true");Y.Assert.isTrue(Kevlar.isBoolean(false),"Test with false");Y.Assert.isFalse(Kevlar.isBoolean([]),"Test with empty array");Y.Assert.isFalse(Kevlar.isBoolean([1,2,3]),"Test with filled array");Y.Assert.isFalse(Kevlar.isBoolean(1),"Test with number");Y.Assert.isFalse(Kevlar.isBoolean(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isBoolean("foo"),"Test with non empty string");Y.Assert.isFalse(Kevlar.isBoolean(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isBoolean(null),"Test with null");Y.Assert.isFalse(Kevlar.isBoolean({}),"Test with object");Y.Assert.isFalse(Kevlar.isBoolean(new Date()),"Test with date")}},{name:"Test isDate()",test_isDate:function(){Y.Assert.isTrue(Kevlar.isDate(new Date()),"Test with simple date");Y.Assert.isTrue(Kevlar.isDate(Date.parseDate("2000","Y")),"Test with simple date");Y.Assert.isFalse(Kevlar.isDate(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isDate(1),"Test with number");Y.Assert.isFalse(Kevlar.isDate("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isDate(null),"Test with null");Y.Assert.isFalse(Kevlar.isDate([]),"Test with array");Y.Assert.isFalse(Kevlar.isDate({}),"Test with object");Y.Assert.isFalse(Kevlar.isDate(jQuery("body")[0]),"Test with element")}},{name:"Test isDefined()",test_isDefined:function(){Y.Assert.isFalse(Kevlar.isDefined(undefined),"Test with undefined");Y.Assert.isTrue(Kevlar.isDefined(null),"Test with null");Y.Assert.isTrue(Kevlar.isDefined({}),"Test with object");Y.Assert.isTrue(Kevlar.isDefined([]),"Test with array");Y.Assert.isTrue(Kevlar.isDefined(new Date()),"Test with date");Y.Assert.isTrue(Kevlar.isDefined(1),"Test with number");Y.Assert.isTrue(Kevlar.isDefined(false),"Test with boolean");Y.Assert.isTrue(Kevlar.isDefined(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isDefined("foo"),"Test with non-empty string");Y.Assert.isTrue(Kevlar.isDefined(jQuery("body")[0]),"Test with element")}},{name:"Test isElement()",test_isElement:function(){Y.Assert.isTrue(Kevlar.isElement(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isElement(null),"Test with null");Y.Assert.isFalse(Kevlar.isElement(1),"Test with number");Y.Assert.isFalse(Kevlar.isElement("foo"),"Test with string")}},{name:"Test isJQuery()",test_isJQuery:function(){Y.Assert.isFalse(Kevlar.isJQuery(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isJQuery(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isJQuery(null),"Test with null");Y.Assert.isFalse(Kevlar.isJQuery(1),"Test with number");Y.Assert.isFalse(Kevlar.isJQuery("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isJQuery(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isJQuery({}),"Test with anonymous object");Y.Assert.isFalse(Kevlar.isJQuery(Kevlar.emptyFn),"Test with function");Y.Assert.isFalse(Kevlar.isJQuery([]),"Test with array");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("body")),"Test with jQuery wrapped set object, with an element");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("#non-existent-element")),"Test with jQuery wrapped set object, without any elements")}},{name:"Test isFunction()",test_isFunction:function(){var b=new Kevlar.util.Observable(),a={fn:function(){}};Y.Assert.isTrue(Kevlar.isFunction(function(){}),"Test with anonymous function");Y.Assert.isTrue(Kevlar.isFunction(new Function('return "";')),"Test with new Function syntax");Y.Assert.isTrue(Kevlar.isFunction(Kevlar.emptyFn),"Test with static function");Y.Assert.isTrue(Kevlar.isFunction(b.fireEvent),"Test with instance function");Y.Assert.isTrue(Kevlar.isFunction(a.fn),"Test with function on object");Y.Assert.isFalse(Kevlar.isFunction(Kevlar.version),"Test with class property");Y.Assert.isFalse(Kevlar.isFunction(null),"Test with null");Y.Assert.isFalse(Kevlar.isFunction(1),"Test with number");Y.Assert.isFalse(Kevlar.isFunction(""),"Test with string");Y.Assert.isFalse(Kevlar.isFunction(new Date()),"Test with date");Y.Assert.isFalse(Kevlar.isFunction([]),"Test with array");Y.Assert.isFalse(Kevlar.isFunction({}),"Test with object")}},{name:"Test isNumber()",test_isNumber:function(){Y.Assert.isTrue(Kevlar.isNumber(0),"Test with 0");Y.Assert.isTrue(Kevlar.isNumber(4),"Test with non-zero integer");Y.Assert.isTrue(Kevlar.isNumber(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isNumber(7.9),"Test with positive float");Y.Assert.isTrue(Kevlar.isNumber(-4.3),"Test with negative float");Y.Assert.isTrue(Kevlar.isNumber(Number.MAX_VALUE),"Test with MAX_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Number.MIN_VALUE),"Test with MIN_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isNumber(Number("3.1")),"Test with Number() constructor");Y.Assert.isFalse(Kevlar.isNumber(Number.NaN),"Test with NaN");Y.Assert.isFalse(Kevlar.isNumber(Number.POSITIVE_INFINITY),"Test with POSITIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(Number.NEGATIVE_INFINITY),"Test with NEGATIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(true),"Test with true");Y.Assert.isFalse(Kevlar.isNumber(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isNumber("1.0"),"Test with string containing a number");Y.Assert.isFalse(Kevlar.isNumber(null),"Test with null");Y.Assert.isFalse(Kevlar.isNumber(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isNumber([]),"Test with array");Y.Assert.isFalse(Kevlar.isNumber({}),"Test with object")}},{name:"Test isObject()",test_isObject:function(){Y.Assert.isTrue(Kevlar.isObject({}),"Test with empty object");Y.Assert.isTrue(Kevlar.isObject({foo:1}),"Test with object with properties");Y.Assert.isTrue(Kevlar.isObject(new Kevlar.util.Observable()),"Test with object instance");Y.Assert.isTrue(Kevlar.isObject(new Object()),"Test with new Object(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(new Date()),"Test with a date object");Y.Assert.isFalse(Kevlar.isObject([]),"Test with array");Y.Assert.isFalse(Kevlar.isObject(new Array()),"Test with new Array(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(1),"Test with number");Y.Assert.isFalse(Kevlar.isObject("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isObject(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isObject(new Number(3)),"Test with new Number() syntax");Y.Assert.isFalse(Kevlar.isObject(new String("foo")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isObject(null),"Test with null");Y.Assert.isFalse(Kevlar.isObject(undefined),"Test with undefined")}},{name:"Test isPrimitive()",test_isPrimitive:function(){Y.Assert.isTrue(Kevlar.isPrimitive(1),"Test with integer");Y.Assert.isTrue(Kevlar.isPrimitive(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isPrimitive(1.4),"Test with floating number");Y.Assert.isTrue(Kevlar.isPrimitive(Number.MAX_VALUE),"Test with Number.MAX_VALUE");Y.Assert.isTrue(Kevlar.isPrimitive(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isPrimitive(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isPrimitive("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isPrimitive(true),"Test with boolean true");Y.Assert.isTrue(Kevlar.isPrimitive(false),"Test with boolean false");Y.Assert.isFalse(Kevlar.isPrimitive(null),"Test with null");Y.Assert.isFalse(Kevlar.isPrimitive(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isPrimitive({}),"Test with object");Y.Assert.isFalse(Kevlar.isPrimitive([]),"Test with array");Y.Assert.isFalse(Kevlar.isPrimitive(new Kevlar.util.Observable()),"Test with object instance")}},{name:"Test isString()",test_isString:function(){var a=new String("foo");Y.Assert.isTrue(Kevlar.isString(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isString("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isString(String("")),"Test with String() syntax");Y.Assert.isFalse(Kevlar.isString(new String("")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isString(1),"Test with number");Y.Assert.isFalse(Kevlar.isString(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isString(null),"Test with null");Y.Assert.isFalse(Kevlar.isString(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isString([]),"Test with array");Y.Assert.isFalse(Kevlar.isString({}),"Test with number")}},{name:"Test namespace()",test_namespace:function(){var a=window;Kevlar.namespace("FooTest1");Y.Assert.isNotUndefined(a.FooTest1,"Test creation with a single top-level namespace");Kevlar.namespace("FooTest2","FooTest3","FooTest4");Y.Assert.isNotUndefined(a.FooTest2,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest3,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest4,"Test creation with multiple top level namespaces");Kevlar.namespace("FooTest5","FooTest5.ns1","FooTest5.ns1.ns2","FooTest5.ns1.ns2.ns3");Y.Assert.isNotUndefined(a.FooTest5,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2.ns3,"Test a chain of namespaces, starting from a top-level");Kevlar.namespace("FooTest6.ns1","FooTest7.ns1");Y.Assert.isNotUndefined(a.FooTest6.ns1,"Test creating lower level namespaces without first defining the top level");Y.Assert.isNotUndefined(a.FooTest7.ns1,"Test creating lower level namespaces without first defining the top level");Kevlar.namespace("FooTest8","FooTest8.ns1.ns2");Y.Assert.isNotUndefined(a.FooTest8,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1.ns2,"Test creating a lower level namespace without defining the middle level");FooTest8.prop1="foo";Kevlar.namespace("FooTest8");Y.Assert.areEqual("foo",FooTest8.prop1,"Ensure existing namespaces are not overwritten")}},{name:"Test toArray()",test_toArray:function(){Y.Assert.isArray(Kevlar.toArray(document.getElementsByTagName("body")),"Test with node list");(function(){var a=Kevlar.toArray(arguments);Y.Assert.isArray(a,"Test with arguments object");Y.Assert.areSame(3,a.length,"Should be 3 args in the array")})(1,2,3)}}]}));(function(){tests.integration=new Ext.test.TestSuite("integration");Ext.test.Session.addSuite(tests.integration)})();tests.integration.add(new Ext.test.TestSuite({name:"Collection with Models",items:[{name:"Test Model Events","changing an attribute in a model should fire a general 'change' event in the Collection":function(){var e=Kevlar.Model.extend({attributes:["attr"]});var f=Kevlar.Collection.extend({model:e});var k=new e({attr:"model1Value1"}),j=new e({attr:"model2Value1"}),g=new f([k,j]);var b=0,d,a,i,h,c;g.on("change",function(p,n,m,o,l){b++;d=p;a=n;i=m;h=o;c=l});k.set("attr","model1Value2");Y.Assert.areSame(1,b,"The call count should now be exactly 1");Y.Assert.areSame(g,d,"The event for model1 should have been fired with the collection that changed");Y.Assert.areSame(k,a,"The event for model1 should have been fired with the model that changed");Y.Assert.areSame("attr",i,"The event for model1 should have been fired with the correct attribute name");Y.Assert.areSame("model1Value2",h,"The event for model1 should have been fired with the new value");Y.Assert.areSame("model1Value1",c,"The event for model1 should have been fired with the old value");j.set("attr","model2Value2");Y.Assert.areSame(2,b,"The call count should now be exactly 2");Y.Assert.areSame(g,d,"The event for model2 should have been fired with the collection that changed");Y.Assert.areSame(j,a,"The event for model2 should have been fired with the model that changed");Y.Assert.areSame("attr",i,"The event for model2 should have been fired with the correct attribute name");Y.Assert.areSame("model2Value2",h,"The event for model2 should have been fired with the new value");Y.Assert.areSame("model2Value1",c,"The event for model2 should have been fired with the old value")},"changing an attribute in a model should fire an attribute-specific 'change' event in the Collection":function(){var e=Kevlar.Model.extend({attributes:["attr"]});var f=Kevlar.Collection.extend({model:e});var j=new e({attr:"model1Value1"}),i=new e({attr:"model2Value1"}),g=new f([j,i]);var b=0,d,a,h,c;g.on("change:attr",function(n,l,m,k){b++;d=n;a=l;h=m;c=k});j.set("attr","model1Value2");Y.Assert.areSame(1,b,"The call count should now be exactly 1");Y.Assert.areSame(g,d,"The event for model1 should have been fired with the collection that changed");Y.Assert.areSame(j,a,"The event for model1 should have been fired with the model that changed");Y.Assert.areSame("model1Value2",h,"The event for model1 should have been fired with the new value");Y.Assert.areSame("model1Value1",c,"The event for model1 should have been fired with the old value");i.set("attr","model2Value2");Y.Assert.areSame(2,b,"The call count should now be exactly 2");Y.Assert.areSame(g,d,"The event for model2 should have been fired with the collection that changed");Y.Assert.areSame(i,a,"The event for model2 should have been fired with the model that changed");Y.Assert.areSame("model2Value2",h,"The event for model2 should have been fired with the new value");Y.Assert.areSame("model2Value1",c,"The event for model2 should have been fired with the old value")},"Any event that the Model fires should be relayed by the Collection":function(){var b=Kevlar.Model.extend({initialize:function(){this.addEvents("testevent")},attributes:["attr"]});var f=Kevlar.Collection.extend({model:b});var k=new b(),j=new b(),h=new f([k,j]);var c=0,g,i,e,d,a;h.on("testevent",function(p,o,n,m,l){c++;g=p;i=o;e=n;d=m;a=l});k.fireEvent("testevent",k,1,2,3);Y.Assert.areSame(1,c,"The testevent should have been called exactly once");Y.Assert.areSame(h,g,"The testevent should have been called with the collection (as it was provided)");Y.Assert.areSame(k,i,"The testevent should have been called with the model (as it was provided)");Y.Assert.areSame(1,e,"arg1 should have been provided");Y.Assert.areSame(2,d,"arg2 should have been provided");Y.Assert.areSame(3,a,"arg3 should have been provided")},"After a model has been removed from the Collection, the collection should no longer relay its events":function(){var e=Kevlar.Model.extend({initialize:function(){this.addEvents("testevent")},attributes:["attr"]});var a=Kevlar.Collection.extend({model:e});var f=new e(),d=new e(),c=new a([f,d]);var b=0;c.on("testevent",function(){b++});c.remove(f);f.fireEvent("testevent");Y.Assert.areSame(0,b,"The testevent should *not* have been fired from the collection, as the child model was removed")}},{name:"Test isModified()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["attr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"isModified() should return false if no Models within the collection have been modified":function(){var c=new this.Model({attr:1}),b=new this.Model({attr:2}),a=new this.Collection([c,b]);Y.Assert.isFalse(a.isModified())},"isModified() should return true if a Model within the collection has been modified":function(){var c=new this.Model({attr:1}),b=new this.Model({attr:2}),a=new this.Collection([c,b]);c.set("attr",42);Y.Assert.isTrue(a.isModified())},"isModified() should return false if a Model within the collection has been modified, but then rolled back or committed":function(){var c=new this.Model({attr:1}),b=new this.Model({attr:2}),a=new this.Collection([c,b]);c.set("attr",42);Y.Assert.isTrue(a.isModified(),"Just double checking that the collection is considered modified, before rolling back");c.rollback();Y.Assert.isFalse(a.isModified(),"Should be false after rollback");c.set("attr",42);Y.Assert.isTrue(a.isModified(),"Just double checking that the collection is considered modified again, before committing");c.commit();Y.Assert.isFalse(a.isModified(),"Should be false after commit")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ModelAttribute",items:[{name:"Test provided set() function","The set() function provided to a ModelAttribute should be passed the instantiated Model if a 'modelClass' config is provided":function(){var d;var b=Kevlar.Model.extend({attributes:["someAttr"]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"model",modelClass:b,set:function(e){d=e;return e}}]});var a=new c({attr:{someAttr:1}});Y.Assert.isInstanceOf(b,d)}},{name:"Test retrieving the inner model from the outer model after it is set","The get() method should be able to retrieve the Model after it has been set":function(){var b=Kevlar.Model.extend({attributes:["someValue"]});var d=Kevlar.Model.extend({attributes:[{name:"innerModel",type:"model",modelClass:b}]});var a=new d({innerModel:{someValue:1}});var c=a.get("innerModel");Y.Assert.isInstanceOf(b,c)}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ModelCache",items:[{name:"Duplicate models should not be able to be instantiated","Instatiating two models of different types, but the same instance ID, should *not* be 'combined' into the same instance":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var a=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var d=new b({id:1});var c=new a({id:1});Y.Assert.areNotSame(d,c)},"Instatiating two models of the same type, but the different instance IDs, should *not* be 'combined' into the same instance":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b({id:1});var a=new b({id:2});Y.Assert.areNotSame(c,a)},"Instantiating two models of both the same type, and which have the same instance ID, should really become the same single instance (i.e. not duplicating it). The same reference should be returned when constructing the duplicate model":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b({id:1});var a=new b({id:1});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object")},"Instantiating two models with the same ID should combine the initial data, with still, only one actual instance should be created":function(){var b=Kevlar.Model.extend({attributes:["id","firstName","lastName"],idAttribute:"id"});var c=new b({id:1,firstName:"Joe"});var a=new b({id:1,lastName:"Shmo"});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object");Y.Assert.areSame("Joe",c.get("firstName"));Y.Assert.areSame("Shmo",c.get("lastName"))}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with NativeObjectConverter",items:[{name:"Test getData()",ttype:"suite",items:[{"Model::getData() should return a key for each of the Attributes in the Model, whether or not any data has been set to them":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new c({attribute1:"value1"});var b=a.getData();Y.ObjectAssert.hasKey("attribute1",b,"The data returned should have attribute1");Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.ObjectAssert.hasKey("attribute2",b,"The data returned should have attribute2, even though no value has been set to it");Y.Assert.isUndefined(b.attribute2,"attribute2 should be undefined in the returned data")},"Model::getData() should return the data by running attributes' `get` functions (not just returning the raw data), when the `raw` option is not provided":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2"});var b=a.getData();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"when the `raw` option is provided as true, Model::getData() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},{name:"attribute3",raw:function(e,d){return e+" "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2",attribute3:"value3"});var b=a.getData({raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned")},"Model::getData() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=a.getData({persistedOnly:true});Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The persisted data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The persisted data should have 'attribute1' and 'attribute3'")}}]},{name:"Test getChanges()",ttype:"suite",items:[{"Model::getChanges() should return a single attribute that has had its value changed":function(){var c=Kevlar.Model.extend({attributes:["attribute1","attribute2"]});var a=new c();a.set("attribute1","new value");var b=a.getChanges();Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 1 property");Y.Assert.areSame("new value",b.attribute1,"The change to attribute1 should have been 'new value'.")},"Model::getChanges() should return multiple attributes that have had their values changed":function(){var c=Kevlar.Model.extend({attributes:["attribute1","attribute2"]});var a=new c();a.set("attribute1","new value 1");a.set("attribute2","new value 2");var b=a.getChanges();Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 2 properties");Y.Assert.areSame("new value 1",b.attribute1,"The change to attribute1 should have been 'new value 1'.");Y.Assert.areSame("new value 2",b.attribute2,"The change to attribute2 should have been 'new value 2'.")},"Model::getChanges() should return the data by running attributes' `get` functions (not just returning the raw data)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},"attribute3"]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data");Y.Assert.isFalse("attribute3" in b,"attribute3 should not exist in the 'changes' data, as it was never changed")},"when the `raw` option is provided as true, Model::getChanges() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},{name:"attribute3",raw:function(e,d){return e+" "+d.get("attribute1")}},{name:"attribute4",defaultValue:"value4"}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");a.set("attribute3","value3");var b=a.getChanges({raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned");Y.Assert.isFalse("attribute4" in b,"attribute4 should not exist in the 'changes' data, as it was never changed")},"Model::getChanges() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) that have been changed when the `persistedOnly` option is set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges({persistedOnly:true});Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The persisted changes should only have 1 property");Y.ObjectAssert.ownsKeys(["attribute1"],b,"The persisted changes should only have 'attribute1'")}}]}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with Nested Collections",items:[{name:"Test setting nested Collections","set() should only change the attribute that a nested Collection is being set to if it is a different Collection than it already has":function(){var e=Kevlar.Model.extend({attributes:[{name:"nestedCollection",type:"collection"}]});var f=Kevlar.Collection.extend({});var a=new e();var c=new f();var b=new f();var d=0;a.addListener("change:nestedCollection",function(){d++});c.on("add",function(){});b.on("remove",function(){});a.set("nestedCollection",c);Y.Assert.areSame(1,d,"The collection should have been set for the first time");a.set("nestedCollection",c);Y.Assert.areSame(1,d,"The collection should not have been re-set, because it is the same collection that is already there");a.set("nestedCollection",b);Y.Assert.areSame(2,d,"The new collection (nestedCollection2) should have been set");a.set("nestedCollection",b);Y.Assert.areSame(2,d,"The new model (nestedModel2) should not have been re-set, because it is the same model that is already there");a.set("nestedCollection",null);Y.Assert.areSame(3,d,"The attribute should have been set to null");a.set("nestedCollection",c);Y.Assert.areSame(4,d,"The attribute should have been set to nestedCollection1 after it had been null")}},{name:"Test the 'change' event for embedded collections","When an attribute has changed in a model of an embedded collection, its parent collection should fire the appropriate 'change' events":function(){var d=Kevlar.Model.extend({attributes:["attr"],toString:function(){return"(ChildModel)"}});var h=Kevlar.Collection.extend({model:d,toString:function(){return"(Collection)"}});var l=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"Collection",embedded:true}],toString:function(){return"(ParentModel)"}});var f=new d({attr:"origValue1"}),e=new d({attr:"origValue2"}),k=new h([f,e]),g=new l({myCollection:k});var b=Class({constructor:function(r,q,s,p){this.model=r;this.attributeName=q;this.newValue=s;this.oldValue=p}});var i=b.extend({constructor:function(t,r,q,s,p){this.collection=t;this._super([r,q,s,p])}});var a=0,n;g.on("change",function(r,q,s,p){a++;n=new b(r,q,s,p)});var m=0,j;g.on("change:myCollection",function(q,r,p){m++;j=new b(q,"",r,p)});var o=0,c;g.on("change:myCollection.*",function(t,r,q,s,p){o++;c=new i(t,r,q,s,p)});window.a=true;f.set("attr","newValue1");window.a=false;Y.Assert.areSame(1,a,"The call count should now be exactly 1");Y.Assert.areSame(g,n.model,"The event for childModel1 should have been fired with the parentModel");Y.Assert.areSame("myCollection",n.attributeName,"The event for childModel1 should have been fired with the correct attribute name");Y.Assert.areSame(k,n.newValue,"The event for childModel1 should have been fired with the newValue of the collection");Y.Assert.areSame(k,n.oldValue,"The event for childModel1 should have been fired with the oldValue of the collection");Y.Assert.areSame(1,m,"The call count should now be exactly 1");Y.Assert.areSame(g,j.model,"The attribute-specific event for childModel1 should have been fired with the parentModel");Y.Assert.areSame(k,j.newValue,"The attribute-specific event for childModel1 should have been fired with the newValue of the collection");Y.Assert.areSame(k,j.oldValue,"The attribute-specific event for childModel1 should have been fired with the oldValue of the collection");Y.Assert.areSame(1,o,"The call count should now be exactly 1");Y.Assert.areSame(k,c.collection,"The attribute-specific event for childModel1 should have been fired with the collection");Y.Assert.areSame(f,c.model,"The attribute-specific event for childModel1 should have been fired with the model that changed");Y.Assert.areSame("attr",c.attributeName,"The event for childModel1 should have been fired with the correct attribute name");Y.Assert.areSame("newValue1",c.newValue,"The attribute-specific event for childModel1 should have been fired with the newValue");Y.Assert.areSame("origValue1",c.oldValue,"The attribute-specific event for childModel1 should have been fired with the oldValue")},"When an attribute has changed in a non-embedded collection, its parent model should *not* fire a 'change' event":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var c=Kevlar.Collection.extend({model:d});var e=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:false}]});var h=new d({attr:"origValue1"}),g=new d({attr:"origValue2"}),f=new c([h,g]),a=new e({myCollection:f});var b=0;a.on("change",function(k,j,l,i){b++});h.set("attr","newValue1");Y.Assert.areSame(0,b,"The call count should be 0 - it is not an embedded collection")},"The parent model should no longer fire events from the child collection after the child collection has been un-set from the parent":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var c=Kevlar.Collection.extend({model:d});var e=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:true}]});var h=new d({attr:"origValue1"}),g=new d({attr:"origValue2"}),f=new c([h,g]),a=new e({myCollection:f});var b=0;a.on("change",function(k,j,l,i){b++});h.set("attr","newValue1");Y.Assert.areSame(1,b,"The call count should now be 1 (as an initial test)");a.set("myCollection",null);h.set("attr","newNewValue1");Y.Assert.areSame(2,b,"We should now only have 2 for the event firing count, as we un-set the child model from the parent (which was the +1), but shouldn't get 3 from childModel1's event")}},{name:'Test that the parent model "has changes" when an embedded collection is changed',"The parent model should have changes when a child embedded collection has changes":function(){var d=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:true}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var b=Kevlar.Collection.extend({model:c});var e=new b([{attr:1},{attr:2}]);var a=new d({myCollection:e});e.getAt(0).set("attr","newValue");Y.Assert.isTrue(a.isModified(),"The parent model should be considered 'modified' while a model in its child collection is 'modified'");Y.Assert.isTrue(a.isModified("myCollection"),"The 'myCollection' attribute should be considered 'modified'")},"The parent model should *not* have changes when a child collection has changes, but is not 'embedded'":function(){var d=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:true}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var b=Kevlar.Collection.extend({model:c});var e=new b([{attr:1},{attr:2}]);var a=new d({myCollection:e});e.getAt(0).set("attr","newValue");Y.Assert.isTrue(a.isModified(),"The parent model should not be considered 'modified' even though its child collection is 'modified', because the child is not 'embedded'")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with Nested Models",items:[{name:"Test setting nested Models","set() should only change the attribute that a nested Model is being set to if it is a different model than it already has":function(){var f=Kevlar.Model.extend({attributes:[{name:"nestedModel",type:"model"}]});var e=Kevlar.Model.extend({attributes:["attr1","attr2"]});var c=new f();var b=new e();var a=new e();var d=0;c.addListener("change:nestedModel",function(){d++});b.on("change:attr1",function(){});a.on("change:attr1",function(){});c.set("nestedModel",b);Y.Assert.areSame(1,d,"The model should have been set for the first time");c.set("nestedModel",b);Y.Assert.areSame(1,d,"The model should not have been re-set, because it is the same model that is already there");c.set("nestedModel",a);Y.Assert.areSame(2,d,"The new model (nestedModel2) should have been set");c.set("nestedModel",a);Y.Assert.areSame(2,d,"The new model (nestedModel2) should not have been re-set, because it is the same model that is already there");c.set("nestedModel",null);Y.Assert.areSame(3,d,"The attribute should have been set to null");c.set("nestedModel",b);Y.Assert.areSame(4,d,"The attribute should have been set to nestedModel1 after it had been null")}},{name:"Test the 'change' event for embedded models","When an attribute has changed in an embedded model, its parent model should fire the appropriate 'change' events":function(){var j=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var f=new c();var d=new j({child:f});var a=function(p,o,q,n){this.model=p;this.attributeName=o;this.newValue=q;this.oldValue=n};var h=0,k;d.on("change",function(p,o,q,n){h++;k=new a(p,o,q,n)});var m=0,l;d.on("change:child",function(o,p,n){m++;l=new a(o,"",p,n)});var g=0,i;d.on("change:child.*",function(p,o,q,n){g++;i=new a(p,o,q,n)});var e=0,b;d.on("change:child.attr",function(o,p,n){e++;b=new a(o,"",p,n)});f.set("attr","asdf");Y.Assert.areSame(1,h,"The parent's general change event should have fired exactly once");Y.Assert.areSame(d,k.model,"The parent's general change event should have fired with the parent model");Y.Assert.areSame("child",k.attributeName,"The parent's general change event should have fired with attributeName for the childModel");Y.Assert.areSame(f,k.newValue,"The parent's general change event should have fired with the new value");Y.Assert.areSame(f,k.oldValue,"The parent's general change event should have fired with the old value");Y.Assert.areSame(1,m,"The childModel-specific change event should have fired exactly once");Y.Assert.areSame(d,l.model,"The childModel-specific change event should have fired with the parent model");Y.Assert.areSame(f,l.newValue,"The childModel-specific change event should have fired with the new value");Y.Assert.areSame(f,l.oldValue,"The childModel-specific change event should have fired with the old value");Y.Assert.areSame(1,g,"The childModel-specific attribute change event should have fired exactly once");Y.Assert.areSame(f,i.model,"The childModel-specific attribute change event should have fired with the child model");Y.Assert.areSame("attr",i.attributeName,"The childModel-specific attribute change event should have fired with attributeName of the changed attribute");Y.Assert.areSame("asdf",i.newValue,"The childModel-specific attribute change event should have fired with the new value");Y.Assert.isUndefined(i.oldValue,"The childModel-specific attribute change event should have fired with the old value");Y.Assert.areSame(1,e,"The attribute-specific change event should have fired exactly once");Y.Assert.areSame(f,b.model,"The attribute-specific change event should have fired with the child model");Y.Assert.areSame("asdf",b.newValue,"The attribute-specific change event should have fired with the new value");Y.Assert.isUndefined(b.oldValue,"The attribute-specific change event should have fired with the old value")},"When an attribute has changed in a non-embedded model, its parent model should *not* fire a 'change' event":function(){var d=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:false}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var e=new c();var a=new d({child:e});var b=false;a.on("change",function(){b=true});e.set("attr","asdf");Y.Assert.isFalse(b)},"The parent model should no longer fire events from the child model after the child model has been un-set from the parent":function(){var d=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var e=new c();var a=new d({child:e});var b=0;a.on("change",function(f,g,h){b++});e.set("attr","asdf");Y.Assert.areSame(1,b,"while the child model is attached, the change event count should have increased by 1");a.set("child",null);e.set("attr","asdf2");Y.Assert.areSame(2,b,"We should only have 2 for the event firing count, as we un-set the child model from the parent (which is the +1), but then events on the childModel beyond that should not be counted")},"When an attribute has changed in a deeply nested embedded model, its parent model should fire a 'change' event, with the parentAttr.childAttr.childAttr attributeName":function(){var n=Kevlar.Model.extend({attributes:[{name:"intermediate",type:"model",embedded:true}],toString:function(){return"(ParentModel)"}});var k=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:true}],toString:function(){return"(IntermediateModel)"}});var b=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}],toString:function(){return"(ChildModel)"}});var a=new n(),l=new k(),o=new b();a.set("intermediate",l);l.set("child",o);var c=function(v,u,w,t){this.model=v;this.attributeName=u;this.newValue=w;this.oldValue=t};var s=0,q;a.on("change",function(v,u,w,t){s++;q=new c(v,u,w,t)});var h=0,p;a.on("change:intermediate",function(u,v,t){h++;p=new c(u,"",v,t)});var d=0,g;a.on("change:intermediate.*",function(v,u,w,t){d++;g=new c(v,u,w,t)});var m=0,j;a.on("change:intermediate.child",function(u,v,t){m++;j=new c(u,"",v,t)});var f=0,r;a.on("change:intermediate.child.*",function(v,u,w,t){f++;r=new c(v,u,w,t)});var e=0,i;a.on("change:intermediate.child.attr",function(u,v,t){e++;i=new c(u,"",v,t)});o.set("attr","asdf");Y.Assert.areSame(1,s,"The general change event should have fired exactly once");Y.Assert.areSame(a,q.model,"The general change event should have fired with the parent model");Y.Assert.areSame("intermediate",q.attributeName,"The general change event should have fired with the attributeName as the intermediate model");Y.Assert.areSame(l,q.newValue,"The general change event should have fired with the intermediate model as the new value");Y.Assert.areSame(l,q.oldValue,"The general change event should have fired with the intermediate model as the old value");Y.Assert.areSame(1,h,"The intermediateModel-specific change event should have fired exactly once");Y.Assert.areSame(a,p.model,"The intermediateModel-specific change event should have fired with the parent model");Y.Assert.areSame(l,p.newValue,"The intermediateModel-specific change event should have fired with the intermediate model as the new value");Y.Assert.areSame(l,p.oldValue,"The intermediateModel-specific change event should have fired with the intermediate model as the old value");Y.Assert.areSame(1,d,"The intermediateModel-specific attribute change event should have fired exactly once");Y.Assert.areSame(l,g.model,"The intermediateModel-specific attribute change event should have fired with the intermediateModel");Y.Assert.areSame("child",g.attributeName,"The intermediateModel-specific attribute change event should have fired with the child model attribute name");Y.Assert.areSame(o,g.newValue,"The intermediateModel-specific attribute change event should have fired with the childModel as the new value");Y.Assert.areSame(o,g.oldValue,"The intermediateModel-specific attribute change event should have fired with the childModel as the old value");Y.Assert.areSame(1,m,"The childModel-specific change event should have fired exactly once");Y.Assert.areSame(l,j.model,"The childModel-specific change event should have fired with the intermediateModel");Y.Assert.areSame(o,j.newValue,"The childModel-specific change event should have fired with the child model as the new value");Y.Assert.areSame(o,j.oldValue,"The childModel-specific change event should have fired with the child model as the old value");Y.Assert.areSame(1,f,"The childModel-specific attribute change event should have fired exactly once");Y.Assert.areSame(o,r.model,"The childModel-specific attribute change event should have fired with the childModel");Y.Assert.areSame("attr",r.attributeName,"The childModel-specific attribute change event should have fired with the child model");Y.Assert.areSame("asdf",r.newValue,"The childModel-specific attribute change event should have fired with the new value");Y.Assert.isUndefined(r.oldValue,"The childModel-specific attribute change event should have fired with the old value");Y.Assert.areSame(1,e,"The childModel attribute-specific change event should have fired exactly once");Y.Assert.areSame(o,i.model,"The childModel attribute-specific change event should have fired with the childModel");Y.Assert.areSame("asdf",i.newValue,"The childModel attribute-specific change event should have fired with the new value");Y.Assert.isUndefined(i.oldValue,"The childModel attribute-specific change event should have fired with the old value")}},{name:'Test that the parent model "has changes" when an embedded model is changed',"The parent model should have changes when a child embedded model has changes":function(){var c=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});var b=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var d=new b();var a=new c({child:d});d.set("attr","newValue");Y.Assert.isTrue(d.isModified(),"As a base test, the child model should be considered 'modified'");Y.Assert.isTrue(a.isModified(),"The parent model should be considered 'modified' while its child model is 'modified'");Y.Assert.isTrue(a.isModified("child"),"The 'child' attribute should be considered 'modified'")},"The parent model should *not* have changes when a child model has changes, but is not 'embedded'":function(){var c=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:false}]});var b=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var d=new b();var a=new c({child:d});d.set("attr","newValue");Y.Assert.isFalse(a.isModified(),"The parent model should not be considered 'modified' even though its child model is 'modified', because the child is not 'embedded'")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ObjectAttribute",items:[{name:"Test defaultValue of ObjectAttribute","The defaultValue for an ObjectAttribute should be null":function(){var b=Kevlar.Model.extend({attributes:[{name:"attr",type:"object"}]});var a=new b();Y.Assert.isNull(a.get("attr"))}}]}));