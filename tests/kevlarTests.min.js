/*!
 * Kevlar JS Library
 * Copyright(c) 2011 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 */
tests.unit=new Ext.test.TestSuite({name:"unit"});tests.unit.persistence=new Ext.test.TestSuite({name:"persistence",parentSuite:tests.unit});tests.unit.util=new Ext.test.TestSuite({name:"util",parentSuite:tests.unit});tests.unit.Kevlar=new Ext.test.TestSuite({parentSuite:tests.unit,name:"Kevlar",items:[{name:"Test apply()",test_apply:function(){var f=Kevlar.apply({},{foo:1,bar:2});Y.ObjectAssert.hasKeys(f,{foo:1,bar:2},"Test simple apply, with a return value");var e={};Kevlar.apply(e,{opt1:"x",opt2:"y"});Y.ObjectAssert.hasKeys(e,{opt1:"x",opt2:"y"},"Test that the reference is changed");var d=Kevlar.apply({},{prop1:1});Y.Assert.isUndefined(d.prop2,"Test to ensure no extra properties are copied");var c=Kevlar.apply({foo:1,baz:4},{foo:2,bar:3});Y.ObjectAssert.hasKeys(c,{foo:2,bar:3,baz:4},"Ensure that properties get overwritten by defaults");var b={};Kevlar.apply(b,{foo:"new",exist:true},{foo:"old",def:true});Y.ObjectAssert.hasKeys(b,{foo:"new",def:true,exist:true},"Test using defaults");var a=Kevlar.apply({},{foo:"foo",bar:"bar"},{foo:"oldFoo",bar:"oldBar"});Y.ObjectAssert.hasKeys(a,{foo:"foo",bar:"bar"},"Test to ensure all defaults get overridden");Y.Assert.isNull(Kevlar.apply(null,{}),"Test null first argument")}},{name:"Test applyIf()",test_applyIf:function(){var d=Kevlar.applyIf({},{foo:"foo",bar:"bar"});Y.ObjectAssert.hasKeys(d,{foo:"foo",bar:"bar"},"Test with an empty destination object");var c=Kevlar.applyIf({foo:"foo"},{foo:"oldFoo"});Y.ObjectAssert.hasKeys(c,{foo:"foo"},"Ensure existing properties don't get overridden");var b=Kevlar.applyIf({foo:1,bar:2},{bar:3,baz:4});Y.ObjectAssert.hasKeys(b,{foo:1,bar:2,baz:4},"Test mixing properties to be overridden");var a={};Kevlar.applyIf(a,{foo:2},{foo:1});Y.ObjectAssert.hasKeys(a,{foo:2},"Test that the reference of the object is changed");Y.Assert.isNull(Kevlar.applyIf(null,{}),"Test null first argument")}},{name:"Test each()",test_each:function(){var d=0;Kevlar.each([1,2,3,4],function(f){d+=f});Y.Assert.areEqual(10,d,"Simple each on an array of numbers");var c="";Kevlar.each(["T","e","s","t","i","n","g"],function(f){c+=f});Y.Assert.areEqual("Testing",c,"Simple each on array of strings");d=0;Kevlar.each(5,function(f){d+=f});Y.Assert.areEqual(5,d,"Test with a non array parameter, number");var e=false;Kevlar.each([],function(){e=true});Y.Assert.isFalse(e,"Test with empty array parameter");e=false;Kevlar.each(null,function(){e=true});Y.Assert.isFalse(e,"Test with null parameter");e=false;Kevlar.each(document.getElementsByTagName("body"),function(){e=true});Y.Assert.isTrue(e,"Test iteration over NodeLists");var a=[];Kevlar.each([1,2,3,4,5,6],function(g,f){a.push(f)});Y.ArrayAssert.itemsAreEqual([0,1,2,3,4,5],a,"Test index is passed correctly");d=0;Kevlar.each([1,2,3,4,5,6],function(f){if(f>4){return false}d+=f});Y.Assert.areEqual(10,d,"Test that returning false stops iteration");d=0;var b={value:3};Kevlar.each([1,2,3],function(f){d+=f*this.value},b);Y.Assert.areEqual(18,d,"Test scope argument #1");d=0;b={value:5};Kevlar.each([1,2,3],function(f){d+=f*this.value},b);Y.Assert.areEqual(30,d,"Test scope argument #2")}},{name:"Test isArray()",test_isArray:function(){var a=Kevlar.extend(Object,{length:1});Y.Assert.isTrue(Kevlar.isArray([]),"Test with empty array");Y.Assert.isTrue(Kevlar.isArray([1,2,3,4]),"Test with filled array");Y.Assert.isFalse(Kevlar.isArray(false),"Test with boolean #1");Y.Assert.isFalse(Kevlar.isArray(true),"Test with boolean #2");Y.Assert.isFalse(Kevlar.isArray("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isArray(1),"Test with number");Y.Assert.isFalse(Kevlar.isArray(null),"Test with null");Y.Assert.isFalse(Kevlar.isArray(new Date()),"Test with a date");Y.Assert.isFalse(Kevlar.isArray({}),"Test with empty object");Y.Assert.isFalse(Kevlar.isArray(document.getElementsByTagName("body")),"Test with node list");Y.Assert.isFalse(Kevlar.isArray(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isArray(new a()),"Test with custom class that has a length property")}},{name:"Test isBoolean()",test_isBoolean:function(){Y.Assert.isTrue(Kevlar.isBoolean(true),"Test with true");Y.Assert.isTrue(Kevlar.isBoolean(false),"Test with false");Y.Assert.isFalse(Kevlar.isBoolean([]),"Test with empty array");Y.Assert.isFalse(Kevlar.isBoolean([1,2,3]),"Test with filled array");Y.Assert.isFalse(Kevlar.isBoolean(1),"Test with number");Y.Assert.isFalse(Kevlar.isBoolean(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isBoolean("foo"),"Test with non empty string");Y.Assert.isFalse(Kevlar.isBoolean(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isBoolean(null),"Test with null");Y.Assert.isFalse(Kevlar.isBoolean({}),"Test with object");Y.Assert.isFalse(Kevlar.isBoolean(new Date()),"Test with date")}},{name:"Test isDate()",test_isDate:function(){Y.Assert.isTrue(Kevlar.isDate(new Date()),"Test with simple date");Y.Assert.isTrue(Kevlar.isDate(Date.parseDate("2000","Y")),"Test with simple date");Y.Assert.isFalse(Kevlar.isDate(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isDate(1),"Test with number");Y.Assert.isFalse(Kevlar.isDate("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isDate(null),"Test with null");Y.Assert.isFalse(Kevlar.isDate([]),"Test with array");Y.Assert.isFalse(Kevlar.isDate({}),"Test with object");Y.Assert.isFalse(Kevlar.isDate(jQuery("body")[0]),"Test with element")}},{name:"Test isDefined()",test_isDefined:function(){Y.Assert.isFalse(Kevlar.isDefined(undefined),"Test with undefined");Y.Assert.isTrue(Kevlar.isDefined(null),"Test with null");Y.Assert.isTrue(Kevlar.isDefined({}),"Test with object");Y.Assert.isTrue(Kevlar.isDefined([]),"Test with array");Y.Assert.isTrue(Kevlar.isDefined(new Date()),"Test with date");Y.Assert.isTrue(Kevlar.isDefined(1),"Test with number");Y.Assert.isTrue(Kevlar.isDefined(false),"Test with boolean");Y.Assert.isTrue(Kevlar.isDefined(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isDefined("foo"),"Test with non-empty string");Y.Assert.isTrue(Kevlar.isDefined(jQuery("body")[0]),"Test with element")}},{name:"Test isElement()",test_isElement:function(){Y.Assert.isTrue(Kevlar.isElement(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isElement(null),"Test with null");Y.Assert.isFalse(Kevlar.isElement(1),"Test with number");Y.Assert.isFalse(Kevlar.isElement("foo"),"Test with string")}},{name:"Test isJQuery()",test_isJQuery:function(){Y.Assert.isFalse(Kevlar.isJQuery(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isJQuery(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isJQuery(null),"Test with null");Y.Assert.isFalse(Kevlar.isJQuery(1),"Test with number");Y.Assert.isFalse(Kevlar.isJQuery("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isJQuery(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isJQuery({}),"Test with anonymous object");Y.Assert.isFalse(Kevlar.isJQuery(Kevlar.emptyFn),"Test with function");Y.Assert.isFalse(Kevlar.isJQuery([]),"Test with array");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("body")),"Test with jQuery wrapped set object, with an element");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("#non-existent-element")),"Test with jQuery wrapped set object, without any elements")}},{name:"Test isFunction()",test_isFunction:function(){var b=new Kevlar.util.Observable(),a={fn:function(){}};Y.Assert.isTrue(Kevlar.isFunction(function(){}),"Test with anonymous function");Y.Assert.isTrue(Kevlar.isFunction(new Function('return "";')),"Test with new Function syntax");Y.Assert.isTrue(Kevlar.isFunction(Kevlar.emptyFn),"Test with static function");Y.Assert.isTrue(Kevlar.isFunction(b.fireEvent),"Test with instance function");Y.Assert.isTrue(Kevlar.isFunction(a.fn),"Test with function on object");Y.Assert.isFalse(Kevlar.isFunction(Kevlar.version),"Test with class property");Y.Assert.isFalse(Kevlar.isFunction(null),"Test with null");Y.Assert.isFalse(Kevlar.isFunction(1),"Test with number");Y.Assert.isFalse(Kevlar.isFunction(""),"Test with string");Y.Assert.isFalse(Kevlar.isFunction(new Date()),"Test with date");Y.Assert.isFalse(Kevlar.isFunction([]),"Test with array");Y.Assert.isFalse(Kevlar.isFunction({}),"Test with object")}},{name:"Test isNumber()",test_isNumber:function(){Y.Assert.isTrue(Kevlar.isNumber(0),"Test with 0");Y.Assert.isTrue(Kevlar.isNumber(4),"Test with non-zero integer");Y.Assert.isTrue(Kevlar.isNumber(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isNumber(7.9),"Test with positive float");Y.Assert.isTrue(Kevlar.isNumber(-4.3),"Test with negative float");Y.Assert.isTrue(Kevlar.isNumber(Number.MAX_VALUE),"Test with MAX_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Number.MIN_VALUE),"Test with MIN_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isNumber(Number("3.1")),"Test with Number() constructor");Y.Assert.isFalse(Kevlar.isNumber(Number.NaN),"Test with NaN");Y.Assert.isFalse(Kevlar.isNumber(Number.POSITIVE_INFINITY),"Test with POSITIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(Number.NEGATIVE_INFINITY),"Test with NEGATIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(true),"Test with true");Y.Assert.isFalse(Kevlar.isNumber(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isNumber("1.0"),"Test with string containing a number");Y.Assert.isFalse(Kevlar.isNumber(null),"Test with null");Y.Assert.isFalse(Kevlar.isNumber(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isNumber([]),"Test with array");Y.Assert.isFalse(Kevlar.isNumber({}),"Test with object")}},{name:"Test isObject()",test_isObject:function(){Y.Assert.isTrue(Kevlar.isObject({}),"Test with empty object");Y.Assert.isTrue(Kevlar.isObject({foo:1}),"Test with object with properties");Y.Assert.isTrue(Kevlar.isObject(new Kevlar.util.Observable()),"Test with object instance");Y.Assert.isTrue(Kevlar.isObject(new Object()),"Test with new Object(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(new Date()),"Test with a date object");Y.Assert.isFalse(Kevlar.isObject([]),"Test with array");Y.Assert.isFalse(Kevlar.isObject(new Array()),"Test with new Array(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(1),"Test with number");Y.Assert.isFalse(Kevlar.isObject("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isObject(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isObject(new Number(3)),"Test with new Number() syntax");Y.Assert.isFalse(Kevlar.isObject(new String("foo")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isObject(null),"Test with null");Y.Assert.isFalse(Kevlar.isObject(undefined),"Test with undefined")}},{name:"Test isPrimitive()",test_isPrimitive:function(){Y.Assert.isTrue(Kevlar.isPrimitive(1),"Test with integer");Y.Assert.isTrue(Kevlar.isPrimitive(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isPrimitive(1.4),"Test with floating number");Y.Assert.isTrue(Kevlar.isPrimitive(Number.MAX_VALUE),"Test with Number.MAX_VALUE");Y.Assert.isTrue(Kevlar.isPrimitive(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isPrimitive(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isPrimitive("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isPrimitive(true),"Test with boolean true");Y.Assert.isTrue(Kevlar.isPrimitive(false),"Test with boolean false");Y.Assert.isFalse(Kevlar.isPrimitive(null),"Test with null");Y.Assert.isFalse(Kevlar.isPrimitive(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isPrimitive({}),"Test with object");Y.Assert.isFalse(Kevlar.isPrimitive([]),"Test with array");Y.Assert.isFalse(Kevlar.isPrimitive(new Kevlar.util.Observable()),"Test with object instance")}},{name:"Test isString()",test_isString:function(){var a=new String("foo");Y.Assert.isTrue(Kevlar.isString(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isString("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isString(String("")),"Test with String() syntax");Y.Assert.isFalse(Kevlar.isString(new String("")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isString(1),"Test with number");Y.Assert.isFalse(Kevlar.isString(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isString(null),"Test with null");Y.Assert.isFalse(Kevlar.isString(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isString([]),"Test with array");Y.Assert.isFalse(Kevlar.isString({}),"Test with number")}},{name:"Test namespace()",test_namespace:function(){var a=window;Kevlar.namespace("FooTest1");Y.Assert.isNotUndefined(a.FooTest1,"Test creation with a single top-level namespace");Kevlar.namespace("FooTest2","FooTest3","FooTest4");Y.Assert.isNotUndefined(a.FooTest2,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest3,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest4,"Test creation with multiple top level namespaces");Kevlar.namespace("FooTest5","FooTest5.ns1","FooTest5.ns1.ns2","FooTest5.ns1.ns2.ns3");Y.Assert.isNotUndefined(a.FooTest5,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2.ns3,"Test a chain of namespaces, starting from a top-level");Kevlar.namespace("FooTest6.ns1","FooTest7.ns1");Y.Assert.isNotUndefined(a.FooTest6.ns1,"Test creating lower level namespaces without first defining the top level");Y.Assert.isNotUndefined(a.FooTest7.ns1,"Test creating lower level namespaces without first defining the top level");Kevlar.namespace("FooTest8","FooTest8.ns1.ns2");Y.Assert.isNotUndefined(a.FooTest8,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1.ns2,"Test creating a lower level namespace without defining the middle level");FooTest8.prop1="foo";Kevlar.namespace("FooTest8");Y.Assert.areEqual("foo",FooTest8.prop1,"Ensure existing namespaces are not overwritten")}},{name:"Test toArray()",test_toArray:function(){Y.Assert.isArray(Kevlar.toArray(document.getElementsByTagName("body")),"Test with node list")}},{name:"Test extend()","extend() should set up simple prototype-chaining inheritance":function(){var c=Kevlar.extend(Object,{constructor:function(d){Kevlar.apply(this,d);this.isBadass=false}});var b=Kevlar.extend(c,{constructor:function(){b.superclass.constructor.apply(this,arguments);this.isBadass=true}});var a=new b({davis:"isAwesome"});Y.Assert.areEqual("isAwesome",a.davis,"Test if David is awesome");Y.Assert.isTrue(a.isBadass,"Test if David is badass");Y.Assert.isFunction(a.override,"Test if extend added the override method");Y.ObjectAssert.areEqual({isBadass:true,davis:"isAwesome"},a,"Test if David is badass and awesome")},"extend() should add static 'constructor' property to the class (constructor function)":function(){var a=Kevlar.extend(Object,{});Y.Assert.areSame(a.constructor,a,"static 'constructor' property not added to constructor function that refers to constructor function")},"extend() should add static 'constructor' property to a subclass (constructor function)":function(){var a=Kevlar.extend(Object,{});var b=Kevlar.extend(a,{});Y.Assert.areSame(b.constructor,b,"static 'constructor' property not added to constructor function that refers to constructor function")},"extend() should add static 'superclass' property to a subclass (constructor function) that refers to its superclass prototype":function(){var a=Kevlar.extend(Object,{});var b=Kevlar.extend(a,{});Y.Assert.areSame(b.superclass,a.prototype,"static 'superclass' property not added to constructor function that refers to constructor function")},"extend() should be able to add in a single mixin class into another class":function(){var d=false;var c=Kevlar.extend(Object,{mixinFn:function(){d=true}});var b=Kevlar.extend(Object,[c],{});var a=new b();a.mixinFn();Y.Assert.isTrue(d,"The mixin function was not properly added to MyClass.")},"extend() should not overwrite a class's methods/properties with a mixin's methods/properties":function(){var c=null;var d=Kevlar.extend(Object,{testProp:"Mixin defined",testMethod:function(){c="Mixin defined"}});var b=Kevlar.extend(Object,[d],{testProp:"MyClass defined",testMethod:function(){c="MyClass defined"}});var a=new b();Y.Assert.areSame("MyClass defined",a.testProp,"The mixin should not overwrite the class's properties");a.testMethod();Y.Assert.areSame("MyClass defined",c,"The mixin's method should not have overwritten the class's method.")},"extend() should have later-defined mixins take precedence over earlier-defined mixins":function(){var b=Kevlar.extend(Object,{testProp:"Mixin1 defined"});var d=Kevlar.extend(Object,{testProp:"Mixin2 defined"});var c=Kevlar.extend(Object,[b,d],{});var a=new c();Y.Assert.areSame("Mixin2 defined",a.testProp,"The second mixin's properties/methods should take precedence over the first one's.")},"extend() should have set up the hasMixin() method, which should check the class for a given mixin":function(){var c=Kevlar.extend(Object,{});var b=Kevlar.extend(Object,{});var a=Kevlar.extend(Object,[c],{});Y.Assert.isTrue(a.hasMixin(c),"MyClass should have the mixin 'Mixin'");Y.Assert.isFalse(a.hasMixin(b),"MyClass should *not* have the mixin 'SomeOtherMixin'")},"extend() should have set up the hasMixin() method, which should check the class and all of its superclasses for a given mixin":function(){var f=Kevlar.extend(Object,{});var d=Kevlar.extend(Object,{});var e=Kevlar.extend(Object,{});var h=Kevlar.extend(Object,{});var b=Kevlar.extend(Object,[f],{});var a=Kevlar.extend(b,[d],{});var j=Kevlar.extend(a,[e],{});for(var c=0;c<=1;c++){var g=(c===0)?"initial":"cached";Y.Assert.isTrue(j.hasMixin(f),"MyClass should have the mixin 'Mixin' from its superclass's superclass. pass = "+g);Y.Assert.isTrue(j.hasMixin(d),"MyClass should have the mixin 'SomeOtherMixin' on its superclass. pass = "+g);Y.Assert.isTrue(j.hasMixin(e),"MyClass should have the mixin 'SomeOtherMixin2' on itself. pass = "+g);Y.Assert.isFalse(j.hasMixin(h),"MyClass should *not* have the mixin 'NobodyHasThisMixin'. pass = "+g)}},"extend() should have set up the hasMixin() method, which should work with mixins and classes defined by regular functions (not using extend())":function(){var g=function(){};var d=function(){};var h=function(){};var b=function(){};var f=Kevlar.extend(b,[g],{});var a=Kevlar.extend(f,[d],{});for(var c=0;c<=1;c++){var e=(c===0)?"initial":"cached";Y.Assert.isTrue(a.hasMixin(g),"MyClass should have the mixin 'Mixin' from its superclass. pass = "+e);Y.Assert.isTrue(a.hasMixin(d),"MyClass should have the mixin 'SomeOtherMixin' on itself. pass = "+e);Y.Assert.isFalse(a.hasMixin(h),"MyClass should *not* have the mixin 'NobodyHasThisMixin'. pass = "+e)}},"extend() should have set up the hasMixin() method on the subclass's prototype, which should work as the static one on an instance's class":function(){var f=Kevlar.extend(Object,{});var d=Kevlar.extend(Object,{});var e=Kevlar.extend(Object,{});var j=Kevlar.extend(Object,{});var b=Kevlar.extend(Object,[f],{});var a=Kevlar.extend(b,[d],{});var k=Kevlar.extend(a,[e],{});var h=new k();for(var c=0;c<=1;c++){var g=(c===0)?"initial":"cached";Y.Assert.isTrue(h.hasMixin(f),"MyClass should have the mixin 'Mixin' from its superclass's superclass. pass = "+g);Y.Assert.isTrue(h.hasMixin(d),"MyClass should have the mixin 'SomeOtherMixin' on its superclass. pass = "+g);Y.Assert.isTrue(h.hasMixin(e),"MyClass should have the mixin 'SomeOtherMixin2' on itself. pass = "+g);Y.Assert.isFalse(h.hasMixin(j),"MyClass should *not* have the mixin 'NobodyHasThisMixin'. pass = "+g)}}},{name:"Test isInstanceOf()","isInstanceOf() should return false for any primitive type":function(){Y.Assert.isFalse(Kevlar.isInstanceOf(undefined,Object),"isInstanceOf should have returned false when given undefined");Y.Assert.isFalse(Kevlar.isInstanceOf(null,Object),"isInstanceOf should have returned false when given null");Y.Assert.isFalse(Kevlar.isInstanceOf(1,Object),"isInstanceOf should have returned false when given a number");Y.Assert.isFalse(Kevlar.isInstanceOf("hi",Object),"isInstanceOf should have returned false when given a string");Y.Assert.isFalse(Kevlar.isInstanceOf(true,Object),"isInstanceOf should have returned false when given a boolean")},"isInstanceOf() should return true when testing an anonymous object with the Object constructor":function(){Y.Assert.isTrue(Kevlar.isInstanceOf({},Object),"isInstanceOf should have returned true")},"isInstanceOf() should return true when testing an object of a class":function(){var a=Kevlar.extend(Object,{constructor:function(){}});var b=new a();Y.Assert.isTrue(Kevlar.isInstanceOf(b,a),"Should have been true. myInstance is an instance of MyClass")},"isInstanceOf() should return true when testing an object that is a subclass of a given class":function(){var a=Kevlar.extend(Object,{constructor:function(){}});var c=Kevlar.extend(a,{constructor:function(){}});var b=new c();Y.Assert.isTrue(Kevlar.isInstanceOf(b,a),"Should have been true. myInstance is an instance of MySubClass, which inherits from MyClass")},"isInstanceOf() should return false when testing an object that is not an instance of a given class":function(){var a=Kevlar.extend(Object,{constructor:function(){}});var c=Kevlar.extend(Object,{constructor:function(){}});var b=new c();Y.Assert.isFalse(Kevlar.isInstanceOf(b,a),"Should have been false. myInstance is not an instance of MyClass")},"isInstanceOf() should return true when testing an object that has a given mixin class":function(){var c=Kevlar.extend(Object,{constructor:function(){}});var a=Kevlar.extend(Object,[c],{constructor:function(){}});var b=new a();Y.Assert.isTrue(Kevlar.isInstanceOf(b,c),"Should have been true. myInstance has the mixin MyMixinClass")},"isInstanceOf() should return true when testing an object that has a given mixin class implemented in its superclass":function(){var d=Kevlar.extend(Object,{constructor:function(){}});var a=Kevlar.extend(Object,[d],{constructor:function(){}});var c=Kevlar.extend(a,{constructor:function(){}});var b=new c();Y.Assert.isTrue(Kevlar.isInstanceOf(b,d),"Should have been true. myInstance has the mixin MyMixinClass through its superclass")},"isInstanceOf() should return true when testing an object that has a given mixin class implemented in its superclass's superclass":function(){var e=Kevlar.extend(Object,{constructor:function(){}});var a=Kevlar.extend(Object,[e],{constructor:function(){}});var d=Kevlar.extend(a,{constructor:function(){}});var c=Kevlar.extend(d,{constructor:function(){}});var b=new c();Y.Assert.isTrue(Kevlar.isInstanceOf(b,e),"Should have been true. myInstance has the mixin MyMixinClass through its superclass's superclass")}}]});Ext.test.Session.addTest({parentSuite:tests.unit,name:"Kevlar.Attribute",setUp:function(){},_should:{error:{"Instantiating an Attribute without a 'name' should throw an error":"no 'name' property provided to Kevlar.Attribute constructor","Instantiating an Attribute with an undefined 'name' argument should throw an error":"no 'name' property provided to Kevlar.Attribute constructor","Instantiating an Attribute with an undefined 'name' property should throw an error":"no 'name' property provided to Kevlar.Attribute constructor","Instantiating an Attribute with a null 'name' argument should throw an error":"no 'name' property provided to Kevlar.Attribute constructor","Instantiating an Attribute with a null 'name' property should throw an error":"no 'name' property provided to Kevlar.Attribute constructor","Instantiating an Attribute with an empty 'name' argument should throw an error":"no 'name' property provided to Kevlar.Attribute constructor","Instantiating an Attribute with an empty 'name' property should throw an error":"no 'name' property provided to Kevlar.Attribute constructor"}},"Instantiating an Attribute without a 'name' should throw an error":function(){var a=new Kevlar.Attribute()},"Instantiating an Attribute with an undefined 'name' argument should throw an error":function(){var a=new Kevlar.Attribute(undefined)},"Instantiating an Attribute with an undefined 'name' property should throw an error":function(){var a=new Kevlar.Attribute({name:undefined})},"Instantiating an Attribute with a null 'name' argument should throw an error":function(){var a=new Kevlar.Attribute(null)},"Instantiating an Attribute with a null 'name' property should throw an error":function(){var a=new Kevlar.Attribute({name:null})},"Instantiating an Attribute with an empty 'name' argument should throw an error":function(){var a=new Kevlar.Attribute("")},"Instantiating an Attribute with an empty 'name' property should throw an error":function(){var a=new Kevlar.Attribute({name:""})},"The name property should be retrievable by getName()":function(){var c=new Kevlar.Attribute({name:"testName"});Y.Assert.areSame("testName",c.getName(),"getName() not properly retriving Attribute's name. Was looking for 'testName'.");var b=new Kevlar.Attribute({name:"_"});Y.Assert.areSame("_",b.getName(),"getName() not properly retriving Attribute's name. Was looking for '_'.");var a=new Kevlar.Attribute({name:"abc"});Y.Assert.areSame("abc",a.getName(),"getName() not properly retriving Attribute's name. Was looking for 'abc'.")},"Providing the attribute name as a number directly to the constructor argument should be converted to a string for the attribute's name":function(){var a=new Kevlar.Attribute(0);Y.Assert.areSame("0",a.getName(),"the attribute name should have been converted to a string")},"Providing the attribute name as a property on the config should be converted to a string for the attribute's name":function(){var a=new Kevlar.Attribute({name:0});Y.Assert.areSame("0",a.getName(),"the attribute name should have been converted to a string")},"A default provided as the keyword 'default' should be accepted properly as defaultValue":function(){var a=new Kevlar.Attribute({name:"TestAttribute","default":1});Y.Assert.areSame(1,a.defaultValue)},"A default provided as the keyword 'default' that is a function should be executed and set properly to defaultValue":function(){var a=new Kevlar.Attribute({name:"TestAttribute","default":function(){return 1}});Y.Assert.areSame(1,a.defaultValue)},"A default provided as defaultValue should be accepted properly":function(){var a=new Kevlar.Attribute({name:"TestAttribute",defaultValue:1});Y.Assert.areSame(1,a.defaultValue)},"A default provided as defaultValue that is a function should be executed and set properly to defaultValue":function(){var a=new Kevlar.Attribute({name:"TestAttribute",defaultValue:function(){return 1}});Y.Assert.areSame(1,a.defaultValue)},"A defaultValue provided as an object should be recursed for functions, and those functions' return values should be used in the default":function(){var b=new Kevlar.Attribute({name:"TestAttribute","default":{a:"A",b:{innerB1:function(){return"B1"},innerB2:"B2"},c:{innerC1:"C",innerC2:function(){return"C2"}}}});var a=b.defaultValue;Y.Assert.areSame("A",a.a,"The 'default' config provided as an object should have had the value 'A' for property 'a'.");Y.Assert.areSame("B1",a.b.innerB1,"The 'default' config provided as an object should have been recursed for functions, and their return values used as the properties.");Y.Assert.areSame("C2",a.c.innerC2,"The 'default' config provided as an object should have been recursed for functions, and their return values used as the properties.")}});tests.unit.Kevlar.Model=new Ext.test.TestSuite({parentSuite:tests.unit,name:"Kevlar.Model",items:[{name:"Test Attributes Inheritance",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},removeArrayDuplicates:function(b){var c=[],e={};for(var d=0,a=b.length;d<a;d++){e[b[d]]=0}for(d in e){if(e.hasOwnProperty(d)){c.push(d)}}return c},assertAttributesHashCorrect:function(){var b=Kevlar.toArray(arguments),e,g;var l=[];for(e=0,g=b.length;e<g;e++){var f=b[e].prototype;if(f.hasOwnProperty("addAttributes")){l=l.concat(b[e].prototype.addAttributes)}}var c=[];for(e=0,g=l.length;e<g;e++){var h=new Kevlar.Attribute(l[e]).getName();c.push(h)}c=this.removeArrayDuplicates(c);var j=c.length;var k=new b[b.length-1](),d=k.attributes;var a=Kevlar.util.Object.length(d);Y.Assert.areSame(j,a,"There should be the same number of resulting attributes in the 'instanceAttributes' hash as the original 'attributes' arrays of the Model classes.");for(e=0,g=c.length;e<g;e++){Y.ObjectAssert.hasKey(c[e],d,"The Model (last arg to assertAttributesHashCorrect) should have defined the '"+c[e]+"' attribute in its final 'attributes' hash")}},"The Kevlar.Model class itself (i.e. no superclass Model) should just have the attributes defined on its prototype.":function(){var a=Kevlar.Model;this.assertAttributesHashCorrect(a)},"Attributes should inherit from a Model subclass's superclass when the subclass defines no attributes of its own":function(){var b=Kevlar.Model;var a=Kevlar.extend(b,{});this.assertAttributesHashCorrect(b,a)},"Attributes should inherit from a Model subclass's superclass when the subclass does define attributes of its own":function(){var c=Kevlar.Model;var b=Kevlar.extend(c,{addAttributes:["a","b"]});this.assertAttributesHashCorrect(c,b);var a=(new b()).attributes;Y.ObjectAssert.hasKey("a",a,"SubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and its superclass as well (i.e. more than one level up)":function(){var d=Kevlar.Model;var b=Kevlar.extend(d,{addAttributes:["a","b"]});var c=Kevlar.extend(b,{addAttributes:["c","d","e"]});this.assertAttributesHashCorrect(d,b,c);var a=(new c()).attributes;Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and all of its superclasses (i.e. more than two levels up)":function(){var e=Kevlar.Model;var c=Kevlar.extend(e,{addAttributes:["a","b"]});var d=Kevlar.extend(c,{addAttributes:["c","d","e"]});var b=Kevlar.extend(d,{addAttributes:["f"]});this.assertAttributesHashCorrect(e,c,d,b);var a=(new b()).attributes;Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("f",a,"SubSubSubClassModel should have the 'f' attribute defined in its final 'attributes' hash.")},"Attribute definitions defined in a subclass should take precedence over attribute definitions in a superclass":function(){var d=Kevlar.Model;var b=Kevlar.extend(d,{addAttributes:[{name:"a",defaultValue:1}]});var c=Kevlar.extend(b,{addAttributes:[{name:"a",defaultValue:2},"b"]});this.assertAttributesHashCorrect(d,b,c);var a=(new c()).attributes;Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.Assert.areSame(2,a.a.defaultValue,"The attribute in the subclass should have overridden its superclass")},"A subclass that doesn't define any attributes should inherit all of them from its superclass(es)":function(){var d=Kevlar.Model;var b=Kevlar.extend(d,{addAttributes:["a","b"]});var c=Kevlar.extend(b,{});this.assertAttributesHashCorrect(d,b,c);var a=(new c()).attributes;Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"A superclass that doesn't define any attributes should be skipped for attributes, but the subclass should still inherit from superclasses above it":function(){var d=Kevlar.Model;var b=Kevlar.extend(d,{});var c=Kevlar.extend(b,{addAttributes:["a","b"]});this.assertAttributesHashCorrect(d,b,c);var a=(new c()).attributes;Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")}},{name:"Test Initialization (the constructor)",ttype:"testsuite",items:[{name:"Test lazy instantiating a proxy",_should:{error:{"Attempting to instantiate a proxy with no 'type' attribute should throw an error":"Kevlar.persistence.proxy.create(): No `type` property provided on proxy config object","Attempting to instantiate a proxy with an invalid 'type' attribute should throw an error":"Kevlar.persistence.Proxy.create(): Unknown Proxy type: 'nonexistentproxy'"}},"Attempting to instantiate a proxy with no 'type' attribute should throw an error":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],proxy:{}});var a=new b()},"Attempting to instantiate a proxy with an invalid 'type' attribute should throw an error":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],proxy:{type:"nonExistentProxy"}});var a=new b()},"Providing a valid config object should instantiate the Proxy *on class's the prototype*":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],proxy:{type:"rest"}});var a=new b();Y.Assert.isInstanceOf(Kevlar.persistence.RestProxy,b.prototype.proxy)},"Providing a valid config object should instantiate the Proxy *on the correct subclass's prototype*, shadowing superclasses":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],proxy:{type:"nonExistentProxy"}});var c=Kevlar.extend(b,{addAttributes:["attribute1"],proxy:{type:"rest"}});var a=new c();Y.Assert.isInstanceOf(Kevlar.persistence.RestProxy,c.prototype.proxy)}},{name:"Test change event upon initialization",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"The Model should fire its 'change' event when an attribute's data is set externally":function(){var b=false;var a=new this.TestModel();a.addListener("change",function(){b=true});a.set("attribute1","value1");Y.Assert.isTrue(b,"The change event should have been fired during the set of the new data")}},{name:"Test that the initial default values are applied",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"A attribute with a defaultValue but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"A attribute with a defaultValue that is a function, but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"A attribute with a defaultValue and also provided data should have its provided data when retrieved":function(){var a=new this.TestModel({attribute2:"attribute2's data"});Y.Assert.areSame("attribute2's data",a.get("attribute2"),"The 'default' specified on the Attribute should *not* have been applied, since it has a value.")}},{name:"Test initial data","Providing initial data to the constructor should not leave the model set as 'dirty' (i.e. it should have no 'changes')":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new b({attribute1:"value1",attribute2:"value2"});Y.Assert.isFalse(a.isDirty(),"The model should not be dirty upon initialization");Y.Assert.isTrue(Kevlar.util.Object.isEmpty(a.getChanges),"There should not be any 'changes' upon initialization")}},{name:"Test that initialize() is called","The initialize() method should be called with the constructor function, for subclass initialization":function(){var b=false;var c=Kevlar.Model.extend({addAttributes:["test",{name:"test2",defaultValue:"defaultForTest2"}],initialize:function(){b=true}});var a=new c();Y.Assert.isTrue(b,"The initialize() method should have been called")}}]},{name:"Test get()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",get:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}}]})},"running get() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.get("attribute1"))},"running get() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.get("attribute1"))},"running get() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"running get() on an attribute with an initial value and a default value should return the initial value":function(){var a=new this.TestModel({attribute2:"initial value"});Y.Assert.areSame("initial value",a.get("attribute2"))},"running get() on an attribute with no initial value but does have a default value which is a function should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"running get() on an attribute with a `get` function defined should return the value that the `get` function returns":function(){var a=new this.TestModel({attribute1:"value1"});Y.Assert.areSame("value1 attribute2's default",a.get("attribute5"))}},{name:"Test set()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},assertAttributeAcceptsAll:function(b,a){b.set(a,undefined);Y.Assert.isUndefined(b.get(a),a+"'s value should have the value set by set() (undefined).");b.set(a,null);Y.Assert.isNull(b.get(a),a+"'s value should have the value set by set() (null).");b.set(a,true);Y.Assert.isTrue(b.get(a),a+"'s value should have the value set by set() (true).");b.set(a,false);Y.Assert.isFalse(b.get(a),a+"'s value should have the value set by set() (false).");b.set(a,0);Y.Assert.areSame(0,b.get(a),a+"'s value should have the value set by set() (0).");b.set(a,1);Y.Assert.areSame(1,b.get(a),a+"'s value should have the value set by set() (1).");b.set(a,"");Y.Assert.areSame("",b.get(a),a+"'s value should have the value set by set() ('').");b.set(a,"Hello");Y.Assert.areSame("Hello",b.get(a),a+"'s value should have the value set by set() ('Hello').");b.set(a,{});Y.Assert.isObject(b.get(a),a+"'s value should have the value set by set() (object).");b.set(a,[]);Y.Assert.isArray(b.get(a),a+"'s value should have the value set by set() (array).")},"set() should accept all datatypes including falsy values":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute1")},"set() should accept all datatypes, and still work even with a default value":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute2")},"set() should accept all datatypes, and still work even with a given value":function(){var a=new this.TestModel({attribute2:"initial value"});this.assertAttributeAcceptsAll(a,"attribute2")},"After the successful set() of an attribute, the Model should be considered 'dirty'":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b();Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isTrue(a.isDirty(),"After a set, the model should now be considered 'dirty'")},"After a set() of an attribute to the same value from a clean state, the Model should NOT be considered 'dirty' (as the value didn't change)":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isFalse(a.isDirty(),"After a set to the *same value*, the model should not be considered 'dirty' (as the value didn't change)")},"set() should not re-set an attribute to the same value from the initial value provided to the constructor":function(){var c=0;var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(0,c,"The attribute should not have been registered as 'changed' when providing the same value")},"set() should not re-set an attribute to the same value":function(){var c=0;var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b();a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(1,c,"Initially, the attribute should have been changed exactly once.");a.set("attribute1","value1");Y.Assert.areSame(1,c,"The attribute should not have been registered as 'changed' the second time. Should still only have '1 change'.")},"set() should run the Attribute's set() method on an attribute that has initial data of its own":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(d,c){return d+" "+c.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute2val attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute1")},"set() should convert an attribute with a 'set' function when it is set() again":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(d,c){return d+" "+c.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});a.set("attribute2","newattribute2value");Y.Assert.areSame("newattribute2value attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute2")},"When an attribute is set, a generalized 'change' event should be fired":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1","attribute2"]});var a=new b(),c=false,d="",e="";a.addListener("change",function(g,f,h){c=true;d=f;e=h});a.set("attribute2","brandNewValue");Y.Assert.isTrue(c,"The 'change' event was not fired");Y.Assert.areSame("attribute2",d,"The attributeName that was changed was not provided to the event correctly.");Y.Assert.areSame("brandNewValue",e,"The value for attribute2 that was changed was not provided to the event correctly.")},"When an attribute is set, a 'change:xxx' event should be fired for the changed attribute":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1","attribute2"]});var a=new b(),c=false,d="";a.addListener("change:attribute2",function(e,f){c=true;d=f});a.set("attribute2","brandNewValue");Y.Assert.isTrue(c,"The 'change:attribute2' event was not fired");Y.Assert.areSame("brandNewValue",d,"The value for attribute2 that was changed was not provided to the event correctly.")},"When an attribute with a `set()` function of its own is set, the 'change' events should be fired":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1",set:function(g){return g}},{name:"attribute2",set:function(h,g){}}]});var a=new b(),e=0,f,c=0,d;a.addListener("change:attribute1",function(g,h){e++;f=h});a.addListener("change:attribute2",function(g,h){c++;d=h});a.set("attribute1","attribute1value1");Y.Assert.areSame(1,e,"The attribute1 change event count should now be 1, with the initial value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value1",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should now be 2, with a new value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value2",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, being set to the same value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");a.set("attribute2","attribute2value1");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it");Y.Assert.areSame(1,c,"The attribute2 change event count should now be 1, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should have been undefined, as its set() function does not return anything");a.set("attribute2","attribute2value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it (2nd time)");Y.Assert.areSame(2,c,"The attribute2 change event count should now be 2, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should still be undefined, as its set() function does not return anything")},"When an attribute with only a `get()` function is set, the 'change' events should be fired with the value from the get function, not the raw value":function(){var d=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"myAttribute",get:function(f,e){return f+10}}]});var b=new d(),c,a;b.on({change:function(f,e,g){c=g},"change:myAttribute":function(e,f){a=f}});b.set("myAttribute",42);Y.Assert.areSame(52,c,"The value provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(52,a,"The value provided with the attribute-specific change event should have come from myAttribute's `get()` function")},"When an attribute with both a `set()` function, and `get()` function of its own is set, the 'change' events should be fired with the value from the `get()` function, not the raw value":function(){var d=Kevlar.extend(Kevlar.Model,{addAttributes:["baseAttribute",{name:"computedAttribute",set:function(f,e){e.set("baseAttribute",f)},get:function(f,e){return e.get("baseAttribute")+10}}]});var b=new d(),c,a;b.on({change:function(f,e,g){c=g},"change:computedAttribute":function(e,f){a=f}});b.set("computedAttribute",42);Y.Assert.areSame(52,c,"The value provided with the change event should have come from the computedAttribute's `get()` function");Y.Assert.areSame(52,a,"The value provided with the attribute-specific change event should have come from the computedAttribute's `get()` function")},"for compatibility with Backbone's Collection, set() should set the id property to the Model object itself with the idAttribute is changed":function(){var b=Kevlar.Model.extend({addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(d,c){return d+" "+c.get("attribute1")}}],idAttribute:"attribute1"});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute1val",a.id,"The model's `id` property should have been set to attribute1's value, as that is the idAttribute.");a.set("attribute1","newValue");Y.Assert.areSame("newValue",a.id,"The model's `id` property should have been set to attribute1's value after another set(), as that is the idAttribute.")}},{name:"Test getDefault()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"A attribute with no defaultValue should return undefined when trying to retrieve its default value":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.getDefault("attribute1"))},"A defaultValue should be able to be retrieved directly when the attribute has one":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.getDefault("attribute2"))},"A defaultValue should be able to be retrieved directly when the defaultValue is a function that returns its default":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.getDefault("attribute3"))}},{name:"Test isDirty()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"isDirty() should return false after instantiating a Model with no data":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after instantiating a Model with initial data":function(){var a=new this.TestModel({attribute1:1,attribute2:2});Y.Assert.isFalse(a.isDirty())},"isDirty() should return true after setting an attribute's data":function(){var a=new this.TestModel();a.set("attribute1",1);Y.Assert.isTrue(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then rolling back the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.rollback();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then committing the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.commit();Y.Assert.isFalse(a.isDirty())}},{name:"Test isModified()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"isModified() should return false for attributes that have not been changed":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1, with no defaultValue, should not be modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2, with a defaultValue, should not be modified")},"isModified() should return true for attributes that have been changed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified");Y.Assert.isTrue(a.isModified("attribute2"),"attribute2 should be marked as modified")},"isModified() should return false for attributes that have been changed, but then committed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been committed, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been committed, and therefore not marked as modified")},"isModified() should return false for attributes that have been changed, but then rolled back":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.rollback();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been rolled back, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been rolled back, and therefore not marked as modified")}},{name:"Test getData()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",get:function(b,a){return"attribute5 "+a.get("attribute2")}}]})},"getData() should return a deep copy of the data, so that the returned object may be modified without messing up the Model":function(){var a=new this.TestModel({attribute1:"attribute1data",attribute2:{nested:"nestedattribute2data"}});var b=a.getData();b.attribute1="newattribute1data";b.attribute2.nested="newnestedattribute2data";Y.Assert.areSame("attribute1data",a.get("attribute1"),"attribute1 in the testModel should not have been modified. getData() not returning a copy of the data?");Y.Assert.areSame("nestedattribute2data",a.get("attribute2").nested,"attribute2 in the testModel should not have been modified. getData() not returning a copy of the data?")},"getData() should return a key for each of the Attributes in the Model, whether or not any data has been set to them":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new c({attribute1:"value1"});var b=a.getData();Y.ObjectAssert.hasKey("attribute1",b,"The data returned should have attribute1");Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.ObjectAssert.hasKey("attribute2",b,"The data returned should have attribute2, even though no value has been set to it");Y.Assert.isUndefined(b.attribute2,"attribute2 should be undefined in the returned data")},"getData() should return the data by running attributes' `get` functions (not just returning the raw data)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2"});var b=a.getData();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"getData() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=a.getData({persistedOnly:true});Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The persisted data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The persisted data should have 'attribute1' and 'attribute3'")}},{name:"Test getChanges()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"getChanges() should return a single attribute that has had its value changed":function(){var a=new this.TestModel();a.set("attribute1","new value");var b=a.getChanges();Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 1 property");Y.Assert.areSame("new value",b.attribute1,"The change to attribute1 should have been 'new value'.")},"getChanges() should return multiple attributes that have had their values changed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");var b=a.getChanges();Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 2 properties");Y.Assert.areSame("new value 1",b.attribute1,"The change to attribute1 should have been 'new value 1'.");Y.Assert.areSame("new value 2",b.attribute2,"The change to attribute2 should have been 'new value 2'.")},"getChanges() should return the data by running attributes' `get` functions (not just returning the raw data)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getData();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"getChanges() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) that have been changed when the `persistedOnly` option is set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges({persistedOnly:true});Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The persisted changes should only have 1 property");Y.ObjectAssert.ownsKeys(["attribute1"],b,"The persisted changes should only have 'attribute1'")}},{name:"Test commit()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"committing changed data should cause the 'dirty' flag to be reset to false, and getChanges() to return an empty object":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();var b=a.getChanges();Y.Assert.areSame(0,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 0 properties");Y.Assert.isFalse(a.isDirty(),"The model should no longer be marked as 'dirty'")},"committing changed data should cause rollback() to have no effect":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();a.rollback();Y.Assert.areSame("new value 1",a.get("attribute1"),"attribute1 should have been 'new value 1'. rollback() should not have had any effect.");Y.Assert.areSame("new value 2",a.get("attribute2"),"attribute2 should have been 'new value 2'. rollback() should not have had any effect.")}},{name:"Test rollback()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"rollback() should revert the model's values back to default values if before any committed set() calls":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.isUndefined(a.get("attribute1"));Y.Assert.areSame("attribute2's default",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values, when more than one set() call is made":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.set("attribute1","new value 1 - even newer");a.set("attribute2","new value 2 - even newer");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")}},{name:"Test load()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},_should:{error:{"load() should throw an error if there is no configured proxy":"Kevlar.Model::load() error: Cannot load. No proxy."}},"load() should throw an error if there is no configured proxy":function(){var a=new this.TestModel({});a.load();Y.Assert.fail("load() should have thrown an error with no configured proxy")},"load() should delegate to its proxy's read() method to retrieve the data":function(){var a=0;var b=Kevlar.persistence.Proxy.extend({read:function(f,e){a++}});var d=this.TestModel.extend({proxy:new b()});var c=new d();c.load();Y.Assert.areSame(1,a,"The proxy's read() method should have been called exactly once")}},{name:"Test save()",ttype:"testsuite",items:[{name:"General save() tests",_should:{error:{"save() should throw an error if there is no configured proxy":"Kevlar.Model::save() error: Cannot save. No proxy."}},"save() should throw an error if there is no configured proxy":function(){var b=Kevlar.Model.extend({});var a=new b();a.save();Y.Assert.fail("save() should have thrown an error with no configured proxy")},"save() should delegate to its proxy's create() method to persist changes when the Model does not have an id set":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);var d=Kevlar.Model.extend({addAttributes:["id"],idAttribute:"id",proxy:a});var b=new d();b.save();try{JsMockito.verify(a).create()}catch(c){Y.Assert.fail("The proxy's update() method should have been called exactly once. "+c)}},"save() should delegate to its proxy's update() method to persist changes, when the Model has an id":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);var d=Kevlar.Model.extend({addAttributes:["id"],idAttribute:"id",proxy:a});var b=new d({id:1});b.save();try{JsMockito.verify(a,JsMockito.Verifiers.once()).update()}catch(c){Y.Assert.fail("The proxy's update() method should have been called exactly once. "+c)}}},{name:"save() callbacks tests",setUp:function(){this.mockProxy=JsMockito.mock(Kevlar.persistence.Proxy);this.mockProxy.create=this.mockProxy.update=function(b,a){if(a.success){a.success.call(a.scope||window)}if(a.error){a.error.call(a.scope||window)}if(a.complete){a.complete(a.scope||window)}};this.Model=Kevlar.Model.extend({addAttributes:["id","attribute1"],proxy:this.mockProxy})},"save should call its 'success' and 'complete' callbacks if the proxy successfully creates":function(){var c=0,a=0;var b=new this.Model();b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the proxy encounters an error while creating":function(){var c=0,a=0;var b=new this.Model();b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'success' and 'complete' callbacks if the proxy successfully updates":function(){var c=0,a=0;var b=new this.Model({id:1});b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the proxy encounters an error while updating":function(){var c=0,a=0;var b=new this.Model({id:1});b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")}},{name:"Test concurrent persistence and model updates",setUp:function(){this.Model=Kevlar.Model.extend({addAttributes:["id","attribute1","attribute2"],proxy:this.mockProxy})},"Model attributes that are updated (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var d=this;var a=Kevlar.extend(Kevlar.persistence.Proxy,{update:function(f,e){window.setTimeout(function(){e.success.call(e.scope||window)},50)}});var c=this.Model.extend({proxy:new a()});var b=new c({id:1});b.set("attribute1","origValue1");b.set("attribute2","origValue2");b.save({success:function(){d.resume(function(){Y.Assert.isTrue(b.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(b.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(b.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue1",b.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",b.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.")})}});b.set("attribute1","newValue1");d.wait(100)},"Model attributes that have been persisted should not be persisted again if they haven't changed since the last persist":function(){var c;var a=Kevlar.persistence.Proxy.extend({update:function(f,e){c=f.getChanges();e.success.call(e.scope)}});var d=this.Model.extend({proxy:new a()});var b=new d({id:1});b.set("attribute1","newattribute1value");b.save();Y.Assert.areSame(1,Kevlar.util.Object.length(c),"The dataToPersist should only have one key after attribute1 has been changed");Y.ObjectAssert.ownsKeys(["attribute1"],c,"The dataToPersist should have 'attribute1'");b.set("attribute2","newattribute2value");b.save();Y.Assert.areSame(1,Kevlar.util.Object.length(c),"The dataToPersist should only have one key after attribute2 has been changed");Y.ObjectAssert.ownsKeys(["attribute2"],c,"The dataToPersist should have 'attribute2'")}}]},{name:"Test destroy()",ttype:"testsuite",items:[{name:"General destroy() tests",_should:{error:{"destroy() should throw an error if there is no configured proxy":"Kevlar.Model::destroy() error: Cannot destroy. No proxy."}},"destroy() should throw an error if there is no configured proxy":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new b();a.destroy();Y.Assert.fail("destroy() should have thrown an error with no configured proxy")},"destroy() should delegate to its proxy's destroy() method to persist the destruction of the model":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);var d=Kevlar.Model.extend({proxy:a});var b=new d();b.destroy();try{JsMockito.verify(a,JsMockito.Verifiers.once()).destroy()}catch(c){Y.Assert.fail("The model should have delegated to the destroy method exactly once.")}},"upon successful destruction of the Model, the Model should fire its 'destroy' event":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);a.destroy=function(f,e){e.success.call(e.scope)};var d=Kevlar.Model.extend({proxy:a});var b=new d();var c=false;b.addListener("destroy",function(){c=true});b.destroy();Y.Assert.isTrue(c,"Should have fired its destroy event")}},{name:"destroy() callbacks tests",setUp:function(){this.mockProxy=JsMockito.mock(Kevlar.persistence.Proxy);this.mockProxy.destroy=function(b,a){if(a.success){a.success.call(a.scope)}if(a.error){a.error.call(a.scope)}if(a.complete){a.complete(a.scope)}}},"destroy() should call its 'success' and 'complete' callbacks if the proxy is successful":function(){var c=0,a=0;var d=Kevlar.Model.extend({attributes:["attribute1"],proxy:this.mockProxy});var b=new d();b.destroy({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"destroy() should call its 'error' and 'complete' callbacks if the proxy encounters an error":function(){var e=0,b=0;var a=JsMockito.mock(Kevlar.persistence.Proxy);a.destroy=function(g,f){f.error.call(f.scope);f.complete(f.scope)};var d=Kevlar.Model.extend({attributes:["attribute1"],proxy:this.mockProxy});var c=new d();c.destroy({error:function(){e++},complete:function(){b++},scope:this});Y.Assert.areSame(1,e,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,b,"The 'complete' function should have been called exactly once")}}]}]});tests.unit.persistence.RestProxy=new Ext.test.TestSuite({parentSuite:tests.unit.persistence,name:"Kevlar.persistence.RestProxy",items:[{name:"Test create",ttype:"testsuite",items:[{name:"General create() tests","create() should populate the model with any response data upon a successful ajax request":function(){var c={attribute1:"value1",attribute2:"value2"};var d=Kevlar.persistence.RestProxy.extend({ajax:function(e){e.success(c)}});var b=new d();var a=JsMockito.mock(Kevlar.Model);b.create(a);try{JsMockito.verify(a).set(c)}catch(f){Y.Assert.fail("The model should have had its data set to the testData")}}},{name:"create()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'POST'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.create(b);Y.Assert.areSame("POST",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{create:"PUT"}});var c=new d();c.create(b);Y.Assert.areSame("PUT",a)}}]},{name:"Test read",ttype:"testsuite",items:[{name:"General read() tests","read() should populate the model data upon a successful ajax request":function(){var c={attribute1:"value1",attribute2:"value2"};var d=Kevlar.persistence.RestProxy.extend({ajax:function(e){e.success(c)}});var b=new d();var a=JsMockito.mock(Kevlar.Model);b.read(a);try{JsMockito.verify(a).set(c)}catch(f){Y.Assert.fail("The model should have had its data set to the testData")}}},{name:"read()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'GET'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.read(b);Y.Assert.areSame("GET",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{read:"POST"}});var c=new d();c.read(b);Y.Assert.areSame("POST",a)}}]},{name:"Test update()",ttype:"testsuite",items:[{name:"General update() tests","update() should NOT actually call the ajax method when no attributes have been changed":function(){var a=0;var d=Kevlar.persistence.RestProxy.extend({ajax:function(){a++}});var c=new d();var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({});c.update(b);Y.Assert.areSame(0,a,"The proxy's ajax() method should not have not been called, since there are no changes")},"update() should in fact call the ajax method when attributes have been changed":function(){var a=0;var d=Kevlar.persistence.RestProxy.extend({ajax:function(){a++}});var c=new d();var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});c.update(b);Y.Assert.areSame(1,a,"The proxy's ajax() method should have been called, since there are changes to persist")}},{name:"Test update() callbacks",setUp:function(){this.ajaxCallCount=0;this.TestProxy=Kevlar.persistence.RestProxy.extend({ajax:jQuery.proxy(function(a){this.ajaxCallCount++;if(a.success){a.success()}if(a.error){a.error()}if(a.complete){a.complete()}},this)})},"The 'success' and 'complete' callbacks provided to update() should be called if no attributes have been changed, and it does not need to do its ajax request":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({});var c=new this.TestProxy();var d=0,a=0;c.update(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,this.ajaxCallCount,"The ajax method should not have been called");Y.Assert.areSame(1,d,"The 'success' callback provided update() should have been called even though there are no changes and the proxy didn't need to persist anything");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called even though there are no changes and the proxy didn't need to persist anything")},"The 'success' and 'complete' callbacks provided to update() should be called if the ajax request is successful":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new this.TestProxy();var d=0,a=0;c.update(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'success' callback provided update() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called")},"The 'error' and 'complete' callbacks provided to update() should be called if the ajax request fails":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new this.TestProxy();var d=0,a=0;c.update(b,{error:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'error' callback provided update() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called")}},{name:"HTTP method tests","By default, the ajax function should be called with the HTTP method 'PUT'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.update(b);Y.Assert.areSame("PUT",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{update:"POST"}});var c=new d();c.update(b);Y.Assert.areSame("POST",a)}},{name:"Test incremental updates",setUp:function(){this.mockModel=JsMockito.mock(Kevlar.Model);JsMockito.when(this.mockModel).getData().thenReturn({attribute1:"value1",attribute2:"value2"});JsMockito.when(this.mockModel).getChanges().thenReturn({attribute2:"value2"})},"update() should provide the full set of data to the ajax method if the proxy is not set to do incremental updates":function(){var a;var d=function(e){a=JSON.parse(e.data)};var c=Kevlar.persistence.RestProxy.extend({ajax:d,incremental:false});var b=new c();b.update(this.mockModel);Y.Assert.areEqual(2,Kevlar.util.Object.length(a),"The dataPersisted have exactly 2 keys, one for each of the attributes in the model");Y.ObjectAssert.ownsKeys(["attribute1","attribute2"],a);Y.Assert.areEqual("value1",a.attribute1);Y.Assert.areEqual("value2",a.attribute2)},"update() should provide only the changed data if the proxy is set to do incremental updates":function(){var a;var d=function(e){a=JSON.parse(e.data)};var c=Kevlar.persistence.RestProxy.extend({ajax:d,incremental:true});var b=new c();b.update(this.mockModel);Y.Assert.areEqual(1,Kevlar.util.Object.length(a),"The dataPersisted have exactly 1 key, the one that was changed");Y.ObjectAssert.ownsKeys(["attribute2"],a);Y.Assert.areEqual("value2",a.attribute2)}}]},{name:"Test destroy",ttype:"testsuite",items:[{name:"Test destroy()'s callbacks","The 'success' and 'complete' callbacks provided to destroy() should be called if the ajax request is successful":function(){var f=function(g){g.success();g.complete()};var e=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:f});var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new e();var d=0,a=0;c.destroy(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'success' callback provided destroy() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided destroy() should have been called")},"The 'error' and 'complete' callbacks provided to destroy() should be called if the ajax request fails":function(){var e=function(g){g.error();g.complete()};var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:e});var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new d();var f=0,a=0;c.destroy(b,{error:function(){f++},complete:function(){a++}});Y.Assert.areSame(1,f,"The 'error' callback provided destroy() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided destroy() should have been called")}},{name:"destroy()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'DELETE'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.destroy(b);Y.Assert.areSame("DELETE",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{destroy:"POST"}});var c=new d();c.destroy(b);Y.Assert.areSame("POST",a)}}]},{name:"Test buildUrl()","buildUrl() should return simply the configured urlRoot, if the 'appendId' config is false":function(){var a=JsMockito.mock(Kevlar.Model);JsMockito.when(a).getId().thenReturn(42);var b=new Kevlar.persistence.RestProxy({urlRoot:"/testUrl",appendId:false});Y.Assert.areSame("/testUrl",b.buildUrl(a),"buildUrl() should have simply still returned the url")},"buildUrl() should return the configured urlRoot with the model's id, if the 'appendId' config is true":function(){var a=JsMockito.mock(Kevlar.Model);JsMockito.when(a).getId().thenReturn(42);var c=new Kevlar.persistence.RestProxy({urlRoot:"/testUrl",appendId:true});Y.Assert.areSame("/testUrl/42",c.buildUrl(a),"buildUrl() should have returned the url with the id appended");var b=new Kevlar.persistence.RestProxy({urlRoot:"/testUrl/",appendId:true});Y.Assert.areSame("/testUrl/42",b.buildUrl(a),"buildUrl() should have returned the url with the id appended")}}]});tests.unit.util.Object=new Ext.test.TestSuite({parentSuite:tests.unit.util,name:"Kevlar.util.Object",items:[{name:"Test clone()","clone() should return primitive types as-is":function(){Y.Assert.areSame(undefined,Kevlar.util.Object.clone(undefined),"clone() not returning undefined when provided undefined.");Y.Assert.areSame(null,Kevlar.util.Object.clone(null),"clone() not returning null when provided null.");Y.Assert.areSame(true,Kevlar.util.Object.clone(true),"clone() not returning true when provided true.");Y.Assert.areSame(false,Kevlar.util.Object.clone(false),"clone() not returning false when provided false.");Y.Assert.areSame(0,Kevlar.util.Object.clone(0),"clone() not returning 0 when provided 0.");Y.Assert.areSame(1,Kevlar.util.Object.clone(1),"clone() not returning 1 when provided 1.");Y.Assert.areSame("",Kevlar.util.Object.clone(""),"clone() not returning empty string when provided an empty string.");Y.Assert.areSame("hi",Kevlar.util.Object.clone("hi"),"clone() not returning string 'hi' when provided string 'hi'.")},"clone() should copy a Date object":function(){var a=new Date(2012,1,1,1,1,1,1);var b=Kevlar.util.Object.clone(a);Y.Assert.areNotSame(a,b,"The copy should not be a reference to the original object");Y.Assert.isTrue(Kevlar.util.Object.isEqual(a,b),"The copy should have the same date value")},"clone() should copy a Date object that is nested within another object":function(){var b=new Date(2012,1,1,1,1,1,1);var c={a:b};var a=Kevlar.util.Object.clone(c);Y.Assert.areNotSame(c,a,"The copy of the object should not be a reference to the input object");Y.Assert.areNotSame(b,a.a,"The date in the 'a' property should be a copy, not a reference to the same object");Y.Assert.isTrue(Kevlar.util.Object.isEqual(c,a),"clone() should have copied the object");Y.Assert.isTrue(Kevlar.util.Object.isEqual(b,a.a),"clone() should have copied the Date object")},"clone() should copy an array of primitives":function(){var a=[1,2,3,4,5];Y.Assert.areNotSame(a,Kevlar.util.Object.clone(a),"clone() returning same reference to array.");Y.Assert.isTrue(Kevlar.util.Object.isEqual([1,2,3,4,5],Kevlar.util.Object.clone(a)),"clone() not properly copying a simple array.")},"clone() should deep copy an array of mixed primitives and objects":function(){var a=[{a:{inner:1},b:2},1,"asdf",[1,2,{a:1}]];Y.Assert.areNotSame(a,Kevlar.util.Object.clone(a),"clone() returning same reference to complex array.");Y.Assert.isTrue(Kevlar.util.Object.isEqual([{a:{inner:1},b:2},1,"asdf",[1,2,{a:1}]],Kevlar.util.Object.clone(a)),"clone() not properly deep copying a complex array.");Y.Assert.areNotSame(a[0],Kevlar.util.Object.clone(a)[0],"clone() not properly deep copying a complex array. first element has same reference for original and copy.");Y.Assert.areNotSame(a[0].a,Kevlar.util.Object.clone(a)[0].a,"clone() not properly deep copying a complex array. first element, 'a' object, has same reference for original and copy.");Y.Assert.areSame(a[0].a,Kevlar.util.Object.clone(a,false)[0].a,"clone() not properly shallow copying a complex array. first element, 'a' object, does not have same reference for original and copy.")},"clone() should copy a simple object of primitives":function(){var a={a:1,b:2};Y.Assert.areNotSame(a,Kevlar.util.Object.clone(a),"clone() returning same reference to simple object.");Y.Assert.isTrue(Kevlar.util.Object.isEqual({a:1,b:2},Kevlar.util.Object.clone(a)),"clone() not properly copying a simple object.")},"clone() should deep copy an object of primitives, nested arrays, and nested objects":function(){var a=new Date(2011,1,1);var b={a:1,b:{a:1,b:[1,2,3],c:{a:null,b:undefined,c:true,d:false,e:"ohai"}},c:[1,[1,2]],d:a};Y.Assert.areNotSame(b,Kevlar.util.Object.clone(b),"clone() returning same reference to complex object.");Y.Assert.isTrue(Kevlar.util.Object.isEqual({a:1,b:{a:1,b:[1,2,3],c:{a:null,b:undefined,c:true,d:false,e:"ohai"}},c:[1,[1,2]],d:a},Kevlar.util.Object.clone(b)),"clone() not properly deep copying a complex object.");Y.Assert.areNotSame(b.b,Kevlar.util.Object.clone(b).b,"clone() not properly deep copying a complex object. property 'b' has same reference for original and copy.");Y.Assert.areNotSame(b.b.c,Kevlar.util.Object.clone(b).b.c,"clone() not properly deep copying a complex object. property 'b.c' has same reference for original and copy. Nested object inside nested object not getting copied.");Y.Assert.areSame(b.b.c,Kevlar.util.Object.clone(b,false).b.c,"clone() with 'deep' set to false (shallow copy mode) is still deep copying a complex object. property 'b.c' does not have same reference for original and copy.");Y.Assert.areNotSame(a,Kevlar.util.Object.clone(b).d,"The Date object in complexObj.d should have been a copy of the Date object, not a reference to the same object")},"clone() should not copy prototype properties of instantiated objects":function(){var a=function(){this.ownVar=1};a.prototype.prototypeVar=2;var b=new a();var c=Kevlar.util.Object.clone(b);Y.Assert.isTrue(c.hasOwnProperty("ownVar"),"clone() did not copy the owned property 'ownVar'");Y.Assert.areSame(1,c.ownVar,"clone() did not copy the owned property 'ownVar' with the correct value");Y.Assert.isFalse(c.hasOwnProperty("prototypeVar"),"clone() copied the prototype property 'prototypeVar'. It should not have.")}},{name:"Test isEqual()","isEqual() should work with all datatype comparisons (primitive and array/object)":function(){var b=Kevlar.util.Object.isEqual;Y.Assert.isTrue(b(undefined,undefined),"Error: undefined !== undefined");Y.Assert.isFalse(b(undefined,null),"Error: undefined === null");Y.Assert.isFalse(b(undefined,true),"Error: undefined === true");Y.Assert.isFalse(b(undefined,false),"Error: undefined === false");Y.Assert.isFalse(b(undefined,0),"Error: undefined === 0");Y.Assert.isFalse(b(undefined,""),"Error: undefined === ''");Y.Assert.isFalse(b(undefined,{}),"Error: undefined === {}");Y.Assert.isFalse(b(undefined,{a:1}),"Error: undefined === { a : 1 }");Y.Assert.isFalse(b(undefined,[]),"Error: undefined === []");Y.Assert.isFalse(b(undefined,[1,2,3]),"Error: undefined === [ 1,2,3 ]");Y.Assert.isFalse(b(undefined,42),"Error: undefined === 42");Y.Assert.isFalse(b(undefined,"test"),"Error: undefined === 'test'");Y.Assert.isTrue(b(null,null),"Error: null !== null");Y.Assert.isFalse(b(null,undefined),"Error: null === undefined");Y.Assert.isFalse(b(null,true),"Error: null === true");Y.Assert.isFalse(b(null,false),"Error: null === false");Y.Assert.isFalse(b(null,0),"Error: null === 0");Y.Assert.isFalse(b(null,""),"Error: null === ''");Y.Assert.isFalse(b(null,{}),"Error: null === {}");Y.Assert.isFalse(b(null,{a:1}),"Error: null === { a : 1 }");Y.Assert.isFalse(b(null,[]),"Error: null === []");Y.Assert.isFalse(b(null,[1,2,3]),"Error: null === [ 1,2,3 ]");Y.Assert.isFalse(b(null,42),"Error: null === 42");Y.Assert.isFalse(b(null,"test"),"Error: null === 'test'");Y.Assert.isTrue(b(true,true),"Error: true !== true");Y.Assert.isTrue(b(false,false),"Error: false !== true");Y.Assert.isFalse(b(true,false),"Error: true === false");Y.Assert.isFalse(b(false,true),"Error: false === true");Y.Assert.isFalse(b(false,0),"Error: false === 0");Y.Assert.isFalse(b(true,1),"Error: true === 1");Y.Assert.isFalse(b(false,""),"Error: false === ''");Y.Assert.isFalse(b(true,"true"),"Error: true === 'true'");Y.Assert.isTrue(b(0,0),"Error: 0 !== 0");Y.Assert.isTrue(b(1,1),"Error: 1 !== 1");Y.Assert.isTrue(b(-1,-1),"Error: -1 !== -1");Y.Assert.isFalse(b(0,1),"Error: 0 === 1");Y.Assert.isFalse(b(1,0),"Error: 1 === 0");Y.Assert.isFalse(b(1,2),"Error: 1 === 2");Y.Assert.isFalse(b(0,""),"Error: 0 === ''");Y.Assert.isFalse(b(1,"1"),"Error: 1 === '1'");Y.Assert.isTrue(b("",""),"Error: '' !== ''");Y.Assert.isTrue(b("asdf","asdf"),"Error: 'asdf' !== 'asdf'");Y.Assert.isFalse(b("",0),"Error: '' === 0");Y.Assert.isFalse(b("asdf","asdf2"),"Error: 'asdf' === 'asdf2'");Y.Assert.isFalse(b(0,"0"),"Error: 0 === '0'");Y.Assert.isFalse(b("0",0),"Error: '0' === 0");Y.Assert.isFalse(b(1,"1"),"Error: 1 === '1'");Y.Assert.isFalse(b("1",1),"Error: '1' === 1");Y.Assert.isFalse(b({},null),"Error: {} === null");Y.Assert.isFalse(b({},undefined),"Error: {} === undefined");Y.Assert.isFalse(b({},true),"Error: {} === true");Y.Assert.isFalse(b({},false),"Error: {} === false");Y.Assert.isFalse(b({},0),"Error: {} === 0");Y.Assert.isFalse(b({},1),"Error: {} === 1");Y.Assert.isFalse(b({},""),"Error: {} === ''");Y.Assert.isFalse(b({},"test"),"Error: {} === 'test'");Y.Assert.isTrue(b({},{}),"Error: {} !== {}");Y.Assert.isFalse(b({},{a:1}),"Error: {} === { a : 1 }");Y.Assert.isFalse(b({},[]),"Error: {} === []");Y.Assert.isFalse(b({},[1,2,3]),"Error: {} === [ 1,2,3 ]");Y.Assert.isFalse(b([],null),"Error: [] === null");Y.Assert.isFalse(b([],undefined),"Error: [] === undefined");Y.Assert.isFalse(b([],true),"Error: [] === true");Y.Assert.isFalse(b([],false),"Error: [] === false");Y.Assert.isFalse(b([],0),"Error: [] === 0");Y.Assert.isFalse(b([],1),"Error: [] === 1");Y.Assert.isFalse(b([],""),"Error: [] === ''");Y.Assert.isFalse(b([],"test"),"Error: [] === 'test'");Y.Assert.isFalse(b([],{}),"Error: [] === {}");Y.Assert.isFalse(b([],{a:1}),"Error: [] === { a : 1 }");Y.Assert.isTrue(b([],[]),"Error: [] !== []");Y.Assert.isFalse(b([],[1,2,3]),"Error: [] === [ 1,2,3 ]");var a=new Date(2012,1,1,10,10,10,10);Y.Assert.isFalse(b(a,null),"Error: date === null");Y.Assert.isFalse(b(a,undefined),"Error: date === undefined");Y.Assert.isFalse(b(a,true),"Error: date === true");Y.Assert.isFalse(b(a,false),"Error: date === false");Y.Assert.isFalse(b(a,0),"Error: date === 0");Y.Assert.isFalse(b(a,1),"Error: date === 1");Y.Assert.isFalse(b(a,""),"Error: date === ''");Y.Assert.isFalse(b(a,"test"),"Error: date === 'test'");Y.Assert.isFalse(b(a,{}),"Error: date === {}");Y.Assert.isFalse(b(a,{a:1}),"Error: date === { a : 1 }");Y.Assert.isFalse(b(a,[]),"Error: date === []");Y.Assert.isFalse(b(a,[1,2,3]),"Error: date === [ 1,2,3 ]");Y.Assert.isFalse(b(a,new Date(2000,1,1,1,1,1,1)),"Error: date === a date with a different date/time");Y.Assert.isTrue(b(a,new Date(2012,1,1,10,10,10,10)),"Error: date !== a date with a the same date/time")},"isEqual() should work with deep object comparisons":function(){var v=Kevlar.util.Object.isEqual;var y={a:"text",b:[0,1]};var x={a:"text",b:[0,1]};var w={a:"text",b:0};var u={a:"text",b:false};var t={a:"text",b:[1,0]};var s={a:"text",b:[1,0],f:function(){this.f=this.b}};var r={a:"text",b:[1,0],f:function(){this.f=this.b}};var q={a:"text",b:[1,0],f:function(){this.a=this.b}};var p={a:"text",c:{b:[1,0],f:function(){this.a=this.b}}};var o={a:"text",c:{b:[1,0],f:function(){this.a=this.b}}};var n={a:"text",b:null};var m={a:"text",b:undefined};Y.Assert.isTrue(v(y,x),"Error w/ object comparison. a !== b");Y.Assert.isFalse(v(y,w),"Error w/ object comparison. a === c");Y.Assert.isFalse(v(w,u),"Error w/ object comparison. c === d");Y.Assert.isFalse(v(y,t),"Error w/ object comparison. a === e");Y.Assert.isTrue(v(s,r),"Error w/ object comparison. f !== g");Y.Assert.isFalse(v(r,q),"Error w/ object comparison. g === h");Y.Assert.isTrue(v(p,o),"Error w/ object comparison. i !== j");Y.Assert.isFalse(v(u,n),"Error w/ object comparison. d === k");Y.Assert.isFalse(v(n,p),"Error w/ object comparison. k === i")},"isEqual() should work with deep array comparisons":function(){var B=Kevlar.util.Object.isEqual;var M=[];var L=[];var K=[1];var J=[1];var I=[2];var H=[2];var G=[1,2,3];var F=[1,2,3];var E=[1,{a:1,b:2},3];var D=[1,{a:1,b:2},3];var C=[[1,2,3],{a:1,b:2},3];var A=[[1,2,3],{a:1,b:2},3];var z=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[1,2]},{c:3}];var y=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[1,2]},{c:3}];var x=[[1,2,3],{a:1,b:2},4];var w=[[1,2,3],{a:11,b:2},4];var v=[[1,22,3],{a:1,b:2},4];var u=[[1,{a:1,b:2,c:3},[1,1,3]],{a:1,b:[1,2]},{c:3}];var t=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[2,2]},{c:3}];Y.Assert.isTrue(B(M,L),"Error w/ array comparison. a !== b");Y.Assert.isTrue(B(K,J),"Error w/ array comparison. c !== d");Y.Assert.isTrue(B(I,H),"Error w/ array comparison. e !== f");Y.Assert.isTrue(B(G,F),"Error w/ array comparison. g !== h");Y.Assert.isTrue(B(E,D),"Error w/ array comparison. i !== j");Y.Assert.isTrue(B(C,A),"Error w/ array comparison. k !== l");Y.Assert.isTrue(B(z,y),"Error w/ array comparison. m !== n");Y.Assert.isFalse(B(M,K),"Error w/ array comparison. a === c");Y.Assert.isFalse(B(L,J),"Error w/ array comparison. b === d");Y.Assert.isFalse(B(K,I),"Error w/ array comparison. c === e");Y.Assert.isFalse(B(J,H),"Error w/ array comparison. d === f");Y.Assert.isFalse(B(I,G),"Error w/ array comparison. e === g");Y.Assert.isFalse(B(H,F),"Error w/ array comparison. f === h");Y.Assert.isFalse(B(G,E),"Error w/ array comparison. g === i");Y.Assert.isFalse(B(F,D),"Error w/ array comparison. h === j");Y.Assert.isFalse(B(E,C),"Error w/ array comparison. i === k");Y.Assert.isFalse(B(D,A),"Error w/ array comparison. j === l");Y.Assert.isFalse(B(C,z),"Error w/ array comparison. k === m");Y.Assert.isFalse(B(A,y),"Error w/ array comparison. l === n");Y.Assert.isFalse(B(E,x),"Error w/ array comparison. i === o");Y.Assert.isFalse(B(C,w),"Error w/ array comparison. k === p");Y.Assert.isFalse(B(z,u),"Error w/ array comparison. m === r");Y.Assert.isFalse(B(y,t),"Error w/ array comparison. n === s")},"isEqual() should be able to shallow compare, with the 'deep' flag set to false, in case objects refer to each other":function(){var g=Kevlar.util.Object.isEqual;var j={};var i={};j.obj2=i;i.obj1=j;var d=[j,i];var c=[j,i];var f;try{f=Kevlar.util.Object.isEqual(d,c,false)}catch(h){Y.Assert.fail("Error w/ shallow array comparison and deep flag set to false. Comparison must be going deep, as this error would come from call stack size being reached.")}Y.Assert.isTrue(f,"Error w/ shallow array comparison. a !== b")}},{name:"Test objLength()","objLength() should return 0 for an empty object":function(){var a={};Y.Assert.areSame(0,Kevlar.util.Object.length(a))},"objLength() should return 0 for an empty object, even if the object has prototype properties":function(){var a=function(){};a.prototype.prop="prototype property";var b=new a();Y.Assert.areSame(0,Kevlar.util.Object.length(b))},"objLength() should return the number of owned properties in the object":function(){var a={prop1:"1",prop2:"2"};Y.Assert.areSame(2,Kevlar.util.Object.length(a))},"objLength() should return the number of owned properties in the object, even if they are undefined or falsy":function(){var a={prop1:undefined,prop2:null,prop3:false,prop4:0,prop5:""};Y.Assert.areSame(5,Kevlar.util.Object.length(a))}},{name:"Test isEmpty()","isEmpty() should return true for an empty object":function(){var a={};Y.Assert.isTrue(Kevlar.util.Object.isEmpty(a))},"isEmpty() should return true for an empty object, even if the object has prototype properties":function(){var a=function(){};a.prototype.prop="prototype property";var b=new a();Y.Assert.isTrue(Kevlar.util.Object.isEmpty(b))},"isEmpty() should return false if the object owns properties":function(){var a={prop1:"1",prop2:"2"};Y.Assert.isFalse(Kevlar.util.Object.isEmpty(a))},"isEmpty() should return false if the object owns properties, even if the properties are undefined or falsy":function(){var a={prop1:undefined,prop2:null,prop3:false,prop4:0,prop5:""};Y.Assert.isFalse(Kevlar.util.Object.isEmpty(a))}}]});tests.unit.util.Observable=new Ext.test.TestSuite({parentSuite:tests.unit.util,name:"Kevlar.util.Observable",setUp:function(){},items:[{name:"Test fireEvent()","firing an event with two listeners, and the first one returns false, should not stop the second from running (returning false should only stop event propagation)":function(){var c=new Kevlar.util.Observable();c.addEvents("testevent");var b=false,a=false;c.addListener("testevent",function(){b=true;return false});c.addListener("testevent",function(){a=true});c.fireEvent("testevent");Y.Assert.isTrue(b,"The first event handler should have been executed");Y.Assert.isTrue(a,"The second event handler should have been executed, even though the first returned false. Returning false should not prevent other handlers from executing, only stop event bubbling.")},"firing an event where one of its handlers returns false should have the call to fireEvent() return false":function(){var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){return false});a.addListener("testevent",function(){});Y.Assert.isFalse(a.fireEvent("testevent"),"Firing the event where the first its two handlers returned false should have caused the return from fireEvent() to be false.");var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){});a.addListener("testevent",function(){return false});Y.Assert.isFalse(a.fireEvent("testevent"),"Firing the event where the second of its two handlers returned false should have caused the return from fireEvent() to be false.");var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){});a.addListener("testevent",function(){return false});a.addListener("testevent",function(){});Y.Assert.isFalse(a.fireEvent("testevent"),"Firing the event where the second of its three handlers returned false should have caused the return from fireEvent() to be false.")},"firing an event where none of its handlers returns false should have the call to fireEvent() return true":function(){var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){});a.addListener("testevent",function(){});Y.Assert.isTrue(a.fireEvent("testevent"),"Firing the event where none of its handlers returned false should have caused the return from fireEvent() to be true.")}},{name:"Test removeListener()","removeListener() should accept an object literal of events to remove":function(){var e=new Kevlar.util.Observable();e.addEvents("evt1","evt2");var c=0,a=0,f=function(){c++},d=function(){a++},b={};e.addListener("evt1",f,b);e.addListener("evt2",d,b);e.fireEvent("evt1");e.fireEvent("evt2");Y.Assert.areSame(1,c,"Initial condition firing should set evt1count to 1");Y.Assert.areSame(1,a,"Initial condition firing should set evt2count to 1");e.removeListener({evt1:f,evt2:d,scope:b});e.fireEvent("evt1");e.fireEvent("evt2");Y.Assert.areSame(1,c,"The evt1count should still be at 1, because the handler was removed");Y.Assert.areSame(1,a,"The evt2count should still be at 1, because the handler was removed")}},{name:"Test event bubbling","firing an event where none of its handlers returns false should have allowed the event to bubble":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isTrue(c,"Firing the event where none of its handlers returned false should have allowed the event to bubble.")},"firing an event where its one handler returns false should have prevented the event from bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){return false});a.fireEvent("testevent");Y.Assert.isFalse(c,"Firing the event its one handler returned false should have prevented the event from bubbling.")},"firing an event where one of its handlers returns false should have prevented the event from bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){return false});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isFalse(c,"Firing the event where the first of its two handlers returned false should have prevented the event from bubbling.");var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.addListener("testevent",function(){return false});a.fireEvent("testevent");Y.Assert.isFalse(c,"Firing the event where the second of its two handlers returned false should have prevented the event from bubbling.")},"Providing the enableBubble() method an object or array of objects should enable bubbling just the same as a string or array of strings":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble({eventName:"testevent"});var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isTrue(c,"The enableBubble() method should have been able to take an object as its argument to enable bubbling for an event.")},"Providing the enableBubble() method a bubbleFn that just returns false should prevent bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble({eventName:"testevent",bubbleFn:function(d){return false}});var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isFalse(c,"A bubbleFn provided to enableBubble() that simply returns false should have prevented the event from bubbling.")},"Providing the enableBubble() method a bubbleFn that returns nothing should NOT prevent bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble({eventName:"testevent",bubbleFn:function(d){}});var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isTrue(c,"A bubbleFn provided to enableBubble() that returns nothing should have NOT prevented the event from bubbling.")}}]});tests.integration=new Ext.test.TestSuite({name:"integration"});tests.integration.Kevlar={};